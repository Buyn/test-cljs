:PROPERTIES:
:header-args: :tangle no :mkdirp yes :results output silent :no-expand t
:END:
* src worder
** src project
*** other
(find-file-other-frame "dev.cljs.edn")
/home/buyn/Dev/ClojureScript/tutorials/my-cljs-project/worder/dev.cljs.edn
(find-file-other-frame "test.cljs.edn")
/home/buyn/Dev/ClojureScript/tutorials/my-cljs-project/worder/test.cljs.edn
(find-file-other-frame "figwheel-main.edn")
/home/buyn/Dev/ClojureScript/tutorials/my-cljs-project/worder/figwheel-main.edn
*** CANCELED deps.edn
:PROPERTIES:
:header-args: :tangle no
:END:
:header-args: :tangle deps.edn
**** file
(find-file-other-frame "deps.edn")
/home/buyn/Dev/ClojureScript/tutorials/my-cljs-project/worder/deps.edn
**** src
***** src deps.edn
#+begin_src clojure :no-expand t
{:deps {org.clojure/clojure {:mvn/version "1.12.0"}
        org.clojure/clojurescript {:mvn/version "1.11.132"}
        org.clojure/data.json {:mvn/version "2.5.1"}
        cljsjs/react {:mvn/version "18.3.1-1"}
        cljsjs/react-dom {:mvn/version "18.3.1-1"}
        org.clojure/core.async     {:mvn/version "0.7.559"
                                    :exclusions  [org.clojure/tools.reader]}
        keechma/keechma            {:mvn/version "0.3.14"
                                    :exclusions [cljsjs/react-with-addons
                                                 cljsjs/react-dom
                                                 cljsjs/react-dom-server]}
        keechma/entitydb           {:mvn/version "0.1.6"}
        reagent/reagent {:mvn/version "0.9.1" }}

 :paths ["src" "resources"]

 :aliases {:fig {:extra-deps
                 {com.bhauman/rebel-readline-cljs {:mvn/version "0.1.4"}
                  com.bhauman/figwheel-main {:mvn/version "0.2.20"}
                  org.slf4j/slf4j-nop {:mvn/version "2.0.16"}}
                 :extra-paths ["target" "test"]}
           :build {:main-opts ["-m" "figwheel.main" "-b" "dev" "-r"]}
           :clean {:main-opts ["-m" "figwheel.main" "--clean" "dev"]}
           :min   {:main-opts ["-m" "figwheel.main" "-O" "advanced" "-bo" "dev"]}
           :test  {:main-opts ["-m" "figwheel.main" "-co" "test.cljs.edn" "-m" "keechma-todomvc.test-runner"]}}}

#+end_src
***** CANCELED orignl
#+begin_src clojure :no-expand t :tangle no 
{:deps {org.clojure/clojure {:mvn/version "1.12.0"}
        org.clojure/clojurescript {:mvn/version "1.11.132"}
        org.clojure/data.json {:mvn/version "2.5.1"}
        cljsjs/react {:mvn/version "18.3.1-1"}
        cljsjs/react-dom {:mvn/version "18.3.1-1"}
        reagent/reagent {:mvn/version "1.2.0" }}
 :paths ["src" "resources"]
 :aliases {:fig {:extra-deps
                 {com.bhauman/rebel-readline-cljs {:mvn/version "0.1.4"}
                  com.bhauman/figwheel-main {:mvn/version "0.2.20"}
                  org.slf4j/slf4j-nop {:mvn/version "2.0.16"}}
                 :extra-paths ["target" "test"]}
           :build {:main-opts ["-m" "figwheel.main" "-b" "dev" "-r"]}
           :clean {:main-opts ["-m" "figwheel.main" "--clean" "dev"]}
           :min   {:main-opts ["-m" "figwheel.main" "-O" "advanced" "-bo" "dev"]}
           :test  {:main-opts ["-m" "figwheel.main" "-co" "test.cljs.edn" "-m" "keechma-todomvc.test-runner"]}}}
#+end_src
** src core
*** components.cljs
:PROPERTIES:
:header-args: :tangle src/keechma_todomvc/components.cljs
:END:
**** file components.cljs
(find-file-other-frame "./src/keechma_todomvc/components.cljs")
**** src components.cljs
#+begin_src clojure :no-expand t :mkdirp yes
(ns keechma-todomvc.components
  "# Todo UI Component system"
  (:require [keechma-todomvc.components.app :as app]
            [keechma-todomvc.components.footer :as footer]
            [keechma-todomvc.components.new-todo :as new-todo]
            [keechma-todomvc.components.todo-edit :as todo-edit]
            [keechma-todomvc.components.timer-button :as timer-button]
            [keechma-todomvc.components.todo-item :as todo-item]
            [keechma-todomvc.components.todo-list :as todo-list]
            [keechma-todomvc.components.toggle-todos :as toggle-todos]))

(def system
  "Defines the component `system`. All the components that send commands
  are configured to send them to the `:todos` topic controller."
  {:main app/component
   :footer (assoc footer/component :topic :todos)
   :new-todo (assoc new-todo/component :topic :todos)
   :todo-edit (assoc todo-edit/component :topic :todos)
   :todo-item (assoc todo-item/component :topic :todos)
   :timer-button (assoc timer-button/component :topic :todos)
   :todo-list todo-list/component
   :toggle-todos (assoc toggle-todos/component :topic :todos)})


#+end_src
*** app.cljs
:PROPERTIES:
:header-args: :tangle src/keechma_todomvc/app.cljs
:END:
**** src app.cljs
#+begin_src clojure :no-expand t :mkdirp yes
(ns keechma-todomvc.app
  "# Keechma TodoMVC App"
  (:require [keechma-todomvc.components :as components]
            [keechma-todomvc.controllers.todos :as todos]
            [keechma-todomvc.subscriptions :as subscriptions]
            [keechma.app-state :as app-state]))

(defonce running-app (atom nil))

;; ## App Definition

(def app-definition
  "Pulls the app together."
  {:routes [[":status" {:status "all"}]]
   :controllers {:todos (todos/->Controller)}
   :components components/system
   :subscriptions subscriptions/subscriptions
   :html-element (.getElementById js/document "app")})

;; ## App Lifecycle

(defn start!
  "Starts the app."
  []
  (reset! running-app (app-state/start! app-definition)))

(defn restart!
  "Restarts the app. `project.clj` contains a config setting for
  `figwheel` requesting a call to this function whenever the code is
  reloaded."
  []
  (if-let [current @running-app]
    (app-state/stop! current start!)
    (start!)))

(defn dev-setup
  "Enables console output for dev builds."
  []
  (when ^boolean js/goog.DEBUG
    (enable-console-print!)
    (println "dev mode")))

;; ## Main

(defn ^:export main
  "Called from `index.html` to start the app. Exported because
  `index.html` refers to it by name even in non-dev builds."
  []
  (dev-setup)
  (start!))


#+end_src
**** file app.cljs
(find-file-other-frame "./src/keechma_todomvc/app.cljs")
*** other
(find-file-other-frame "./src/keechma_todomvc/subscriptions.cljs")
(find-file-other-frame "./src/keechma_todomvc/ui.cljs")
(find-file-other-frame "./src/keechma_todomvc/util.cljs")
(find-file-other-frame "./src/keechma_todomvc/edb.cljs")
(find-file-other-frame "./src/keechma_todomvc/edb.clj")
*** CANCELED worder.cljs
:PROPERTIES:
:header-args: :tangle no
:END:
:header-args: :tangle src/keechma_todomvc/worder.cljs
**** file worder.cljs
(find-file-other-frame "src/keechma_todomvc/worder.cljs")
**** src worder.cljs
***** test version src worder.cljs
#+begin_src clojure :no-expand t :mkdirp yes
(ns ^:figwheel-hooks keechma-todomvc.worder
  (:require
   [keechma-todomvc.components :as components]
   [keechma-todomvc.controllers.todos :as todos]
   [keechma-todomvc.subscriptions :as subscriptions]
   [reagent.core :as reagent :refer [atom]]
   [keechma.app-state :as app-state]))

(defn multiply [a b] (* a b))

(defonce running-app (atom nil))

(def app-definition
  {:routes [["/:status" {:status "all"}]]
   :controllers {:todos (todos/->Controller)}
   :components components/system
   :subscriptions subscriptions/subscriptions
   :html-element (.getElementById js/document "app")})

(defn start! []
  (reset! running-app (app-state/start! app-definition)))

(defn restart! []
  (if-let [current @running-app]
    (app-state/stop! current start!)
    (start!)))

(defn dev-setup []
  (when ^boolean js/goog.DEBUG
    (enable-console-print!)
    (println "dev mode")))

(defn ^:export main []
  (dev-setup)
  (start!))

(defn ^:after-load on-reload []
  (restart!))


#+end_src
***** keechma version src worder.cljs
#+begin_src clojure :no-expand t :mkdirp yes :tangle no
(ns ^:figwheel-hooks keechma-todomvc.worder
  "# Keechma TodoMVC App"
  (:require [keechma-todomvc.components :as components]
            [keechma-todomvc.controllers.todos :as todos]
            [keechma-todomvc.subscriptions :as subscriptions]
            [keechma.app-state :as app-state]))


(defn multiply [a b] (* a b))

(defonce running-app (atom nil))

;; ;; ## App Definition

(def app-definition
  "Pulls the app together."
  {:routes [[":status" {:status "all"}]]
   :controllers {:todos (todos/->Controller)}
   :components components/system
   :subscriptions subscriptions/subscriptions
   :html-element (.getElementById js/document "app")})

;; ## App Lifecycle

(defn start!
  "Starts the app."
  []
  (reset! running-app (app-state/start! app-definition)))

(defn restart!
  "Restarts the app. `project.clj` contains a config setting for
  `figwheel` requesting a call to this function whenever the code is
  reloaded."
  []
  (if-let [current @running-app]
    (app-state/stop! current start!)
    (start!)))

(defn dev-setup
  "Enables console output for dev builds."
  []
  (when ^boolean js/goog.DEBUG
    (enable-console-print!)
    (println "dev mode")))

;; ;; ## Main

(defn ^:export main
  "Called from `index.html` to start the app. Exported because
  `index.html` refers to it by name even in non-dev builds."
  []
  (dev-setup)
  (start!))


(dev-setup)
(start!)
(println "This text is printed from src/keechma_todomvc/worder.cljs. Go ahead and edit it and see reloading in action.")


#+end_src
***** src worder.cljs
#+begin_src clojure :no-expand t :mkdirp yes :tangle no
(ns ^:figwheel-hooks keechma-todomvc.worder
  "# Keechma TodoMVC App"
  (:require [keechma-todomvc.components :as components]
            [keechma-todomvc.controllers.todos :as todos]
            [keechma-todomvc.subscriptions :as subscriptions]
            [goog.dom :as gdom]
            [reagent.core :as reagent :refer [atom]]
            [reagent.dom :as rdom]
            [keechma.app-state :as app-state]))

;; (ns ^:figwheel-hooks keechma-todomvc.worder
;;   (:require
;;    [goog.dom :as gdom]
;;    [reagent.core :as reagent :refer [atom]]
;;    [reagent.dom :as rdom]))

(defn multiply [a b] (* a b))

(defonce running-app (atom nil))

;; ;; ## App Definition

(def app-definition
  "Pulls the app together."
  {:routes [[":status" {:status "all"}]]
   :controllers {:todos (todos/->Controller)}
   :components components/system
   :subscriptions subscriptions/subscriptions
   :html-element (.getElementById js/document "app")})

;; ## App Lifecycle

(defn start!
  "Starts the app."
  []
  (reset! running-app (app-state/start! app-definition)))

(defn restart!
  "Restarts the app. `project.clj` contains a config setting for
  `figwheel` requesting a call to this function whenever the code is
  reloaded."
  []
  (if-let [current @running-app]
    (app-state/stop! current start!)
    (start!)))

(defn dev-setup
  "Enables console output for dev builds."
  []
  (when ^boolean js/goog.DEBUG
    (enable-console-print!)
    (println "dev mode")))

;; ;; ## Main

(defn ^:export main
  "Called from `index.html` to start the app. Exported because
  `index.html` refers to it by name even in non-dev builds."
  []
  (dev-setup)
  (start!))

(println "This text is printed from src/keechma_todomvc/worder.cljs. Go ahead and edit it and see reloading in action.")

;; (defn multiply [a b] (* a b))

;; define your app data so that it doesn't get over-written on reload
(defonce app-state (atom {:text "Hello world!"}))

(defn get-app-element []
  (gdom/getElement "app"))

(defn hello-world []
  [:div
   [:h1 (:text @app-state)]
   [:h3 "Edit this in src/keechma_todomvc/worder.cljs and watch it change!"]])

(defn mount [el]
  (rdom/render [hello-world] el))

(defn mount-app-element []
  (when-let [el (get-app-element)]
    (mount el)))

;; conditionally start your application based on the presence of an "app" element
;; this is particularly helpful for testing this ns without launching the app
(mount-app-element)
;; (dev-setup)
;; (start!)

;; specify reload hook with ^:after-load metadata
(defn ^:after-load on-reload []
  (mount-app-element)
  ;; (dev-setup)
  ;; optionally touch your app-state to force rerendering depending on
  ;; your application
  ;; (swap! app-state update-in [:__figwheel_counter] inc)
)

;; (defn ^:after-load on-reload []
;;   (restart!))
#+end_src
***** CANCELED original figwheel template
#+begin_src clojure :no-expand t :mkdirp yes :tangle no 
(ns ^:figwheel-hooks keechma-todomvc.worder
  (:require
   [goog.dom :as gdom]
   [reagent.core :as reagent :refer [atom]]
   [reagent.dom :as rdom]))

(println "This text is printed from src/keechma_todomvc/worder.cljs. Go ahead and edit it and see reloading in action.")

(defn multiply [a b] (* a b))

;; define your app data so that it doesn't get over-written on reload
(defonce app-state (atom {:text "Hello world!"}))

(defn get-app-element []
  (gdom/getElement "app"))

(defn hello-world []
  [:div
   [:h1 (:text @app-state)]
   [:h3 "Edit this in src/keechma_todomvc/worder.cljs and watch it change!"]])

(defn mount [el]
  (rdom/render [hello-world] el))

(defn mount-app-element []
  (when-let [el (get-app-element)]
    (mount el)))

;; conditionally start your application based on the presence of an "app" element
;; this is particularly helpful for testing this ns without launching the app
(mount-app-element)

;; specify reload hook with ^:after-load metadata
(defn ^:after-load on-reload []
  (mount-app-element)
  ;; optionally touch your app-state to force rerendering depending on
  ;; your application
  ;; (swap! app-state update-in [:__figwheel_counter] inc)
)
#+end_src
**** repl

# (ns ^:figwheel-hooks keechma-todomvc.worder
(require `[keechma-todomvc.worder :as worder-main]

(in-ns `keechma-todomvc.worder)
**** exampl
(find-file-other-frame "./src/keechma_todomvc/app.cljs")
** src components
*** components/app.cljs
:PROPERTIES:
:header-args: :tangle ./src/keechma_todomvc/components/app.cljs
:END:
**** file components/app.cljs
(find-file-other-frame "./src/keechma_todomvc/components/app.cljs")
**** src components/app.cljs
#+begin_src clojure :no-expand t :mkdirp yes 
(ns keechma-todomvc.components.app
  "# Main app component"
  (:require [keechma-todomvc.ui :refer [<comp comp> sub>]]))

(defn render
  "## Renders the top level UI

  Some elements are rendered inline, others are implemented as
  `components`. Each `component` will have its own `context` provided.

### Component Deps

- `:new-todo` top field where new `todos` are entered
- `:toggle-todos` checkbox to the left of `:new-todo`
- `:todo-list` main body list of `todos`
- `:footer` active count, filtering, clearing

### Subscription Deps

- `:has-todos?` returns true if there are any todos in the EntityDB."
  [ctx]
  [:<>
   [:section.todoapp
    [:header.header
     [:h1 "Worder"]
     [comp> ctx :new-todo]]
    (when (sub> ctx :has-todos?)
      [:<>
       [:section.main
        [comp> ctx :toggle-todos]
        [comp> ctx :todo-list]]
       [comp> ctx :footer]])]
   [:footer.info
    [:p "Double-click to edit a todo"]
    [:p
     [:a {:href "https://keechma.com"} "Keechma"] " "
     [:a {:href "http://todomvc.com"} "TodoMVC"]]]])

(def component
  (<comp :renderer render
         :component-deps [:new-todo
                          :toggle-todos
                          :todo-list
                          :footer]
         :subscription-deps [:has-todos?]))

#+end_src


**** exempls
(find-file-other-frame "~/Dev/ClojureScript/tutorials/my-cljs-project/example-todomvc/src/keechma_todomvc/components/app.cljs")
**** CANCELED arhiv
:PROPERTIES:
:header-args: :tangle no
:END:
***** 01 src components/app.cljs
#+begin_src clojure :no-expand t :mkdirp yes 
(ns keechma-todomvc.components.app
  "# Main app component"
  (:require [keechma-todomvc.ui :refer [<comp comp> sub>]]))

(defn render
  "## Renders the top level UI

  Some elements are rendered inline, others are implemented as
  `components`. Each `component` will have its own `context` provided.

### Component Deps

- `:new-todo` top field where new `todos` are entered
- `:toggle-todos` checkbox to the left of `:new-todo`
- `:todo-list` main body list of `todos`
- `:footer` active count, filtering, clearing

### Subscription Deps

- `:has-todos?` returns true if there are any todos in the EntityDB."
  [ctx]
  [:<>
   [:section.todoapp
    [:header.header
     [:h1 "Worder"]
     [comp> ctx :new-todo]]
    (when (sub> ctx :has-todos?)
      [:<>
       [:section.main
        [comp> ctx :toggle-todos]
        [comp> ctx :todo-list]]
       [comp> ctx :footer]])]
   [:footer.info
    [:p "Double-click to edit a todo"]
    [:p
     [:a {:href "https://keechma.com"} "Keechma"] " "
     [:a {:href "http://todomvc.com"} "TodoMVC"]]]])

(def component
  (<comp :renderer render
         :component-deps [:new-todo
                          :toggle-todos
                          :todo-list
                          :footer]
         :subscription-deps [:has-todos?]))

#+end_src


***** old
     [comp> ctx :timer-button]
                          :timer-button
     [:h1 "Worder"]
     ;; [comp> ctx :timer-button]
     [comp> ctx :new-todo]]

*** components/todo_edit.cljs
:PROPERTIES:
:header-args: :tangle ./src/keechma_todomvc/components/todo_edit.cljs
:END:
**** file
(find-file-other-frame "./src/keechma_todomvc/components/todo_edit.cljs")
**** src
#+begin_src clojure :no-expand t :mkdirp yes 
(ns keechma-todomvc.components.todo-edit
  "# Todo Edit component"
  (:require [keechma-todomvc.ui :refer [<cmd <comp sub>]]
            [keechma-todomvc.util :refer [is-enter? is-esc?]]
            [reagent.core :as reagent]))

(defn form-3-render
  "## Renders an Edit Field

### Form 3 render function

  Returns a `reagent class` created from a map that allows us to
  provide additional component data to `reagent` including
  implementations for `react lifecycle functions` like
  `:component-did-mount`.

### Subscription Deps

- `:edit-todo` returns the `todo` currently being edited, or nil

### Note

  This component is using a `form 3` render function to demonstrate
  the additional flexibility it allows. In this case, we could get the
  same effect by setting the `:auto-focus` attribute on the
  `:input.edit` element to `true` within a `form 2` render function."
  [ctx]
  (let [edit-todo (sub> ctx :edit-todo)
        todo-title (reagent/atom (:title edit-todo))
        handle-change #(reset! todo-title (.. % -target -value))
        update #(<cmd ctx :confirm-edit (assoc edit-todo :title @todo-title))
        cancel #(<cmd ctx :cancel-edit)
        handle-key-down #(let [key-code (.-keyCode %)]
                           (when (is-enter? key-code) (update))
                           (when (is-esc? key-code) (cancel)))
        render (fn []
                 [:input.edit {:value @todo-title
                               :on-blur update
                               :on-change handle-change
                               :on-key-down handle-key-down}])
        focus-input #(let [node (reagent/dom-node %)
                           length (count (.-value node))]
                       (.focus node)
                       (.setSelectionRange node length length))]
    (reagent/create-class
     {:display-name "todo-edit"
      :reagent-render render
      :component-did-mount focus-input})))

(def component
  (<comp :renderer form-3-render
         :subscription-deps [:edit-todo]))
#+end_src
**** exempl
(find-file-other-frame "~/Dev/ClojureScript/tutorials/my-cljs-project/example-todomvc/src/keechma_todomvc/components/todo_edit.cljs")

*** components/timer_button.cljs
:PROPERTIES:
:header-args: :tangle ./src/keechma_todomvc/components/timer_button.cljs
:END:
**** file timer_button.cljs
(find-file-other-frame "./src/keechma_todomvc/components/timer_button.cljs")
**** src timer_button.cljs
#+begin_src clojure :no-expand t :mkdirp yes 
(ns keechma-todomvc.components.timer-button
  (:require [keechma-todomvc.ui :refer [<comp comp> sub> <cmd]]
            [reagent.core :as r]))

(defn render [ctx todo]
  (let [seconds (r/atom 0)
        timer-id (r/atom nil)
        start-ms (r/atom nil)
        running? #(not (= @timer-id nil))
        counter #(reset! seconds (/ (- (.now js/Date) @start-ms) 1000))
        stop! (fn []
                (counter)
                (js/clearInterval @timer-id)
                (reset! timer-id nil)
                (reset! start-ms nil)
                (<cmd ctx
                      :update-todo-time
                      {:id (:id todo) :time @seconds :todo todo}))
        start! (fn []
                  (reset! start-ms (.now js/Date))
                  (reset! timer-id (js/setInterval counter 100)))
        toggle! #(if (running?) (stop!) (start!))]  
    (fn []
      [:div.timer {:class (when (running?) "running")}
       [:button
        {:on-click toggle!} 
        (if (running?) "■ Stop" "▶ Start")]
       [:span.seconds (str @seconds " sec")]])))

(def component
  (<comp :renderer render))
#+end_src
**** ИИ
***** я изменил немного функцию и довай изменим логигику
timer-button
он должен состоять из двух элементов. и реагент атома.
кнопка и отображаемое значение.
кнопка запускает секудомер. повторное нажатие останавливает секундомер.
количество прошедших секунд отображает во втором элементе.
принцип работы создаём атом за пределами функции. 
запоминет время сейчас
и каждые 0.5 секунды высчитвает текушее время - запомненое.
и помешает в атом.
и довай сделаем это только на основе одно атома в котором будет конечный результат секунты.
остальные перменные предлогаю сделать врмеными и не атомами. Чтоб не плодить сушности.
отображение секунт сточностью до милесикунд через запятую
***** 
(defn render [ctx]
  (let [seconds (r/atom 0)
        timer-id (atom nil)
        start-ts (atom nil)
        toggle! (fn [_]
                  (if @timer-id
                    ;; Stop
                    (do (js/clearInterval @timer-id)
                        (reset! timer-id nil)
                        (reset! start-ts nil))
                    ;; Start
                    (let [now (.now js/Date)]
                      (reset! start-ts now)
                      (reset! timer-id
                              (js/setInterval
                                (fn []
                                  (let [elapsed (/ (- (.now js/Date) @start-ts) 1000)]
                                    (reset! seconds (Math/floor elapsed))))
                                500)))))]
    
    (fn []
        [:div.timer
          [:button
            {:on-click triger-fn}
            (if @running? "■ Stop" "▶ Start")]
          [:span.seconds (str @seconds " sec.")]])))

***** хочу сделать новый компонент
timer-button
он должен состоять из двух элементов. и реагент атома.
кнопка и отображаемое значение.
кнопка запускает секудомер. повторное нажатие останавливает секундомер.
количество прошедших секунд отображает во втором элементе.
принцип работы создаём атом за пределами функции. 
запоминет время сейчас
и каждые 0.5 секунды высчитвает текушее время - запомненое.
и помешает в атом.
**** CANCELED arhiv
:PROPERTIES:
:header-args: :tangle no
:END:
***** 02 src timer_button.cljs
#+begin_src clojure :no-expand t :mkdirp yes 
(ns keechma-todomvc.components.timer-button
  (:require [keechma-todomvc.ui :refer [<comp comp> sub>]]
            [reagent.core :as r]))

(defn render [_ctx]
  (let [seconds (r/atom 0)
        timer-id (r/atom nil)
        stop! (fn [] (do (js/clearInterval @timer-id)
                 (reset! timer-id nil)))
        start! (fn [] (let [start-ms (.now js/Date)]
                 (reset! timer-id
                       (js/setInterval
                        (fn []
                          (let [elapsed (/ (- (.now js/Date) start-ms) 1000)]
                            (reset! seconds elapsed)))
                        100))))
        toggle! (fn [_] (if @timer-id (stop!) (start!)))]  

    (fn []
      [:div.timer
       [:button
        {:on-click toggle!} 
        (if @timer-id "■ Stop" "▶ Start")]
       [:span.seconds (str @seconds " sec")]])))

(def component
  (<comp :renderer render))
#+end_src
***** src 01 timer_button.cljs
#+begin_src clojure :no-expand t :mkdirp yes 
(ns keechma-todomvc.components.timer-button
  (:require [keechma-todomvc.ui :refer [<comp comp> sub>]]
            [reagent.core :as r]))

(defn render [_ctx]
  (let [seconds (r/atom 0)    ;; здесь живёт только результат
        timer-id (r/atom nil)
        toggle! (fn [_]
           (if @timer-id
             ;; Stop
             (do (js/clearInterval @timer-id)
                 (reset! timer-id nil))
             ;; Start
             (let [start-ms (.now js/Date)]
               (reset! timer-id
                       (js/setInterval
                        (fn []
                          (let [elapsed (/ (- (.now js/Date) start-ms) 1000)]
                            (reset! seconds elapsed)))
                        100)))))]  

    (fn []
      [:div.timer
       [:button
        {:on-click toggle!} 
        (if @timer-id "■ Stop" "▶ Start")]
       [:span.seconds (str @seconds " sec")]])))

(def component
  (<comp :renderer render))
#+end_src
***** src error
#+begin_src clojure :no-expand t :mkdirp yes 
(ns keechma-todomvc.components.timer-button
  (:require [keechma-todomvc.ui :refer [<comp comp> sub>]]
            [reagent.core :as r]))

(defn render [_ctx]
  (let [seconds (r/atom 0)
        timer-id (atom nil)
        activ? (= @timer-id nil) 
        start-ms (atom 0)
        toggle! (fn [_]
           (if @timer-id
             ;; Stop
             (do (js/clearInterval @timer-id)
                 (reset! timer-id nil)
                 (let [elapsed (/ (- (.now js/Date) @start-ms) 1000)]
                    (reset! seconds elapsed)))
             ;; Start
             (do (reset! @start-ms (.now js/Date))
                 (reset! timer-id
                      (js/setInterval
                        (fn []
                          (let [elapsed (/ (- (.now js/Date) @start-ms) 1000)]
                            (reset! seconds elapsed)))
                        100)))))]  
    (fn []
      [:div.timer
       [:button
        {:on-click toggle!} 
        (if (activ?) "■ Stop" "▶ Start")]
       [:span.seconds (str @seconds " sec")]])))

(def component
  (<comp :renderer render))
#+end_src
***** src 02
#+begin_src clojure :no-expand t :mkdirp yes 
(ns keechma-todomvc.components.timer-button
  (:require [keechma-todomvc.ui :refer [<comp comp> sub>]]
            [reagent.core :as r]))

(defn render [_ctx]
  (let [seconds (r/atom 0)    ;; здесь живёт только результат
        timer-id (atom nil)
        togle! (fn [_]
           (if @timer-id
             ;; Stop
             (do (js/clearInterval @timer-id)
                 (reset! timer-id nil))
             ;; Start
             (let [start-ms (.now js/Date)]
               (reset! timer-id
                       (js/setInterval
                        (fn []
                          (let [elapsed (/ (- (.now js/Date) start-ms) 1000)]
                            (reset! seconds elapsed)))
                        100)))))]  

    (fn []
      [:div.timer
       [:button
        {:on-click togle!} 
        (if @timer-id "■ Stop" "▶ Start")]
       [:span.seconds
        (str @seconds " sec")
        ;; (-> @seconds
        ;;     (* 100)
        ;;     (Math/round)
        ;;     (/ 100)
        ;;     (str " sec"))
        ]])))
(def component
  (<comp :renderer render
         ;; :component-deps [:new-todo
         ;;                  :toggle-todos
         ;;                  :todo-list
         ;;                  :footer]
         ;; :subscription-deps [:has-todos?]
         ))
#+end_src
***** src 01
#+begin_src clojure :no-expand t :mkdirp yes 
(ns keechma-todomvc.components.timer-button
  (:require [keechma-todomvc.ui :refer [<comp comp> sub>]]
            [reagent.core :as r]))

(defn render [ctx]
  (let [running? (r/atom false)
          seconds  (r/atom 0)
          timer-id (r/atom nil)]
      (fn []
        [:div.timer
          [:button
            {:on-click
              (fn [_]
                (if @running?
                  (do
                    (swap! running? not)
                    (js/clearInterval @timer-id)
                    (reset! timer-id nil))
                  (do
                    (reset! seconds 0)
                    (swap! running? not)
                    (reset! timer-id
                            (js/setInterval
                              #(swap! seconds inc)
                              1000)))))}
            (if @running? "■ Stop" "▶ Start")]
          [:span.seconds (str @seconds " sec.")]])))

(def component
  (<comp :renderer render
         ;; :component-deps [:new-todo
         ;;                  :toggle-todos
         ;;                  :todo-list
         ;;                  :footer]
         ;; :subscription-deps [:has-todos?]
         ))
#+end_src
**** reple
***** atom

(def timer-id (reagent.core/atom nil))

(= @timer-id nil)

(reset! timer-id 3)

@timer-id

(= @timer-id nil)

(def running? (not (= timer-id nil)))
running?
(running?)
{:class (when (running?) "running")}
***** command
  (:require [keechma-todomvc.ui :refer [<comp comp> sub> <cmd]]

(keechma-todomvc.ui\<cmd 2 :update-todo-time 12 13))
***** js

(js/console.log
  (clj->js
    (-> @keechma.app-state/app-db :entities :todos)))
***** get app
(def app-db (-> keechma-todomvc.app/running-app deref :app-db))
(keechma-todomvc.edb/get-collection @app-db :todos :list)

:todos-by-status

(def app-db (-> keechma-todomvc.app/running-app deref :app-db))



;; вывести размер todo-коллекции
(-> @app-db (get-in [:entities :todos :entities]) count)

;; вывести первый todo
(-> @app-db (get-in [:entities :todos :entities]) first val)
(println "Keys in app-db:" (keys @app-db))



@(-> keechma-todomvc.app/running-app deref :app-db)
(def app-db (-> keechma-todomvc.app/running-app deref :app-db))
@app-db
(require '[keechma-todomvc.edb :as edb])
(edb/get-collection @app-db :todos :list)
(edb/get-item-by-id @app-db :todos "todo123")
***** todos-by-status

(def app-db (-> keechma-todomvc.app/running-app deref :app-db))
(keechma-todomvc.edb/get-collection @app-db :todos :list)

(defn todos-by-status
  "Returns all `todos` with a `status`."
  [app-db status]
  (let [todos (edb/get-collection app-db :todos :list)]
    (case status
      :completed (filter :completed todos)
      :active (filter (complement :completed) todos)
      :all todos)))

:todos-by-status

(find-file-other-frame "./src/keechma_todomvc/components/todo_list.cljs")

(sub> app-db :todos-by-status :all)

(keechma-todomvc.ui/sub> app-db :todos-by-status "all")

(def app-db (-> keechma-todomvc.app/running-app deref :app-db))
(keechma-todomvc.edb/get-collection app-db :todos :list)

(keechma-todomvc.edb/get-collection app-db :todos :list)

(-> app-db :entities :todos)   
(-> app-db :entities)   

(-> keechma-todomvc.app/running-app :entities)


(:app-db (deref keechma-todomvc.app/running-app))
(:entities (:app-db @keechma-todomvc.app/running-app))
*** components/todo_item.cljs
:PROPERTIES:
:header-args: :tangle ./src/keechma_todomvc/components/todo_item.cljs
:END:
**** file components/todo_item.cljs
(find-file-other-frame "./src/keechma_todomvc/components/todo_item.cljs")
**** src components/todo_item.cljs
#+begin_src clojure :no-expand t :mkdirp yes 
(ns keechma-todomvc.components.todo-item
  "# Todo Item component"
  (:require [keechma-todomvc.ui :refer [<cmd <comp comp>]]))

(defn render
  "## Renders a todo list item

  The item's content includes:

- a `checkbox` for toggling `:completed`
- a `label` displaying the `:title`
- a `button` to delete the item

If the item is currently being edited, overlays a `todo-edit` component.

### Component Deps

- `:todo-edit` presents ui to edit a `todo`'s title

### Arguments

  This render function has arguments in addition to `ctx`. Values for
  those are provided at the site where this component is included
  within another, in this case `:todo-list`. If this were a `form-2`
  render function, the returned function would have only `todo` and
  `is-editing?` as arguments."
  [ctx todo is-editing?]
  [:li {:class [(when is-editing? :editing)
                (when (:completed todo) :completed)]}
   [:div.view {:on-double-click #(<cmd ctx :start-edit todo)}
    [:input.toggle {:type :checkbox
                    :checked (:completed todo)
                    :on-change #(<cmd ctx :toggle-todo todo)}]
    [:label (:title todo)
      [comp> ctx :timer-button todo]]
    [:button.destroy {:on-click #(<cmd ctx :delete-todo todo)}]]
   (when is-editing?
     [comp> ctx :todo-edit])])

(def component
  (<comp :renderer render
         :component-deps [:todo-edit
                          :timer-button]))

#+end_src
     
**** exempls
(find-file-other-frame "~/Dev/ClojureScript/tutorials/my-cljs-project/example-todomvc/src/keechma_todomvc/components/todo_item.cljs")
*** other
(find-file-other-frame "./src/keechma_todomvc/components/new_todo.cljs")
(find-file-other-frame "./src/keechma_todomvc/components/toggle_todos.cljs")
(find-file-other-frame "./src/keechma_todomvc/components/todo_list.cljs")
(find-file-other-frame "./src/keechma_todomvc/components/footer.cljs")

** src entities
*** entities/todo.cljs
:PROPERTIES:
:header-args: :tangle ./src/keechma_todomvc/entities/todo.cljs
:END:
**** file entities/todo.cljs
(find-file-other-frame "./src/keechma_todomvc/entities/todo.cljs")
**** src entities/todo.cljs
#+begin_src clojure :no-expand t :mkdirp yes 
(ns keechma-todomvc.entities.todo
  "# Todo Entities"
  (:require [clojure.string :as str]
            [keechma-todomvc.edb :as edb])
  (:import [goog.ui IdGenerator]))

;; ## Helpers

(def id-generator (IdGenerator.))

(defn id
  "Returns a unique ID for a new todo."
  []
  (.getNextUniqueId id-generator))

(defn valid-title?
  "Returns `true` if `title` is a valid `todo` title."
  [title]
  (not (str/blank? title)))

;; ## Subscription Support (Read)

(defn todos-by-status
  "Returns all `todos` with a `status`."
  [app-db status]
  (let [todos (edb/get-collection app-db :todos :list)]
    (case status
      :completed (filter :completed todos)
      :active (filter (complement :completed) todos)
      :all todos)))

(defn edit-todo
  "Returns the `todo` currently being edited."
  [app-db]
  (->> (get-in app-db [:kv :editing-id])
       (edb/get-item-by-id app-db :todos)))

;; ## Action Support (Write)

;; ### Edit Management

(defn start-edit
  "Sets state: this `todo` is currently being edited."
  [app-db {:keys [id] :as todo}]
  (assoc-in app-db [:kv :editing-id] id))

(defn cancel-edit
  "Clears state: no `todo` is currently being edited."
  [app-db]
  (assoc-in app-db [:kv :editing-id] nil))

(defn confirm-edit
  "Updates `todo` if `new-todo` has a valid `title`."
  [app-db {:keys [id title] :as new-todo}]
  (assert id)
  (if (valid-title? title)
    (-> app-db
        (cancel-edit)
        (edb/insert-item :todos new-todo))
    app-db))

;; ### Create, Update, Delete Todos

(defn create-todos
  "Creates an empty `todos` list."
  [app-db]
  (edb/insert-collection app-db :todos :list []))

(defn create-todo
  "If `title` is valid, creates a new `todo` and inserts it at the
  beginning of the `todo` list."
  [app-db title]
  (if (valid-title? title)
    (let [todo {:id (str "todo" (id))
                :completed false
                :title title}]
      (edb/prepend-collection app-db :todos :list [todo]))
    app-db))

(defn update-todo
  "Merges new data into a `todo`. `patch-todo` must have an `:id`
  value that is the `id` of the `todo` to be updated."
  [app-db {:keys [id] :as patch-todo}]
  (assert id)
  (edb/insert-item app-db :todos patch-todo))

(defn update-todo-time
  "Updates the `:time` value on an existing todo item.
  This handler expects a map with the `:todo`, `:id` and new `:time` value.
  If the todo exists, a new todo map is created with the updated time
  and stored back in the EntityDB.
  Arguments:
  - app-db: The current application state atom
  - {:keys [id time todo]}: A map containing the todo ID and the new time (in seconds)
  Returns:
  - The updated `app-db` value
  Notes:
  - If `id` or `todo` is missing, the original `app-db` unchanged."
  [app-db {:keys [id time todo]}]
  (assert id)
  (assert todo)
  (let [updated-todo (assoc todo :time time)]
    (edb/insert-item app-db :todos updated-todo)))

(defn toggle-todo
  "Toggles the `:completed` status of a saved `todo`."
  [app-db todo]
  (update-todo app-db (update todo :completed not)))

(defn toggle-all
  "Marks all `todos` as completed or not based on `completed?`."
  [app-db completed?]
  (reduce (fn [acc todo]
            (update-todo acc (assoc todo :completed completed?)))
          app-db
          (todos-by-status app-db :all)))

(defn delete-todo
  "Removes a `todo` from the EntityDB."
  [app-db {:keys [id] :as todo}]
  (edb/remove-item app-db :todos id))

(defn delete-completed
  "Removes all completed `todos` from the EntityDB."
  [app-db]
  (reduce (fn [acc {:keys [id]}]
            (edb/remove-item acc :todos id))
          app-db
          (todos-by-status app-db :completed)))

;; ## Actions for keechma.controllers/dispatcher

(defn actions
  "Returns a mapping from `todo` topic `command` keywords to `action`
  functions. The mapping is suitable for use by
  `keechma.controller/dispatcher`.

  Adapts the calling convention from the one used by
  `keechma.controllers/dispatcher`:

  `(action-fn app-db-atom args-vec)`

  to one that is more natural for ClojureScript:

  `(handler app-db-atom arg1 arg2 arg3 ...)`.

  Combined with `<cmd` in `ui.cljs`, this allows natural-looking
  arguments in calls to `<cmd` to be handled by a handler with a
  natural looking argument vector in its definition. This insulates
  app developers from the restriction against varags in protocol
  functions that results in `keechma.ui-component/send-command`
  supporting only exactly 2 or 3 args, the last one an optional
  explicit vector of additional args.

  The adapter also provides the side-effect of updating the `app-db`
  with the result of each call, allowing the handlers to be written
  and tested as pure functions that return the new `app-db` value."
  []
  (let [cmd-handlers {:start-edit start-edit
                      :cancel-edit cancel-edit
                      :confirm-edit confirm-edit
                      :create-todo create-todo
                      :delete-todo delete-todo
                      :toggle-todo toggle-todo
                      :toggle-all toggle-all
                      :update-todo-time update-todo-time
                      :delete-completed delete-completed}
        action-adapter (fn [f]
                         (fn [app-db args]
                           (apply swap! app-db f args)))]
    (reduce-kv (fn [acc k f]
                 (assoc acc k (action-adapter f)))
               {}
               cmd-handlers)))

#+end_src
     
**** exempls
(find-file-other-frame "~/Dev/ClojureScript/tutorials/my-cljs-project/example-todomvc/src/keechma_todomvc/entities/todo.cljs")
**** CANCELED archiv
:PROPERTIES:
:header-args: :tangle no
:END:
***** 01 update-todo-time
(defn update-todo-time
  [app-db {:keys [id time]}]
  ;; (assert id)
  ;; (let [todo (edb/get-item-by-id app-db :todos id)
  ;;       updated-todo (assoc todo :time time)]
  ;;   (edb/insert-item app-db :todos updated-todo))
  (println "test!!!!")
  app-db)

***** update-todo-time
(defn update-todo-time
  [app-db {:keys [id] :as patch-todo}]
  ;; (assert id)
  ;; (println patch-todo)
  ;; (println time)
  (println "test!")
  ;; сохранить time внутри туду
  ;; и новерно вызвать update-todo
  )

** src resources
*** index.html
:PROPERTIES:
:header-args: :tangle ./resources/public/index.html
:END:
**** file
(find-file-other-frame "./resources/public/index.html")
**** src
#+begin_src html :no-expand t :mkdirp yes 
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Worder • Keechma</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="css/style.css" rel="stylesheet" type="text/css">
    <link rel="icon" href="https://clojurescript.org/images/cljs-logo-icon-32.png">
  </head>
  <body>
    <div id="app"> 
    </div> <!-- end of app div -->
    <script src="js/app.js" type="text/javascript"></script>
    <script>keechma_todomvc.app.main()</script>
  </body>
</html>
#+end_src
**** exampl
(find-file-other-frame "/home/buyn/Dev/ClojureScript/tutorials/my-cljs-project/group-chat/resources/public/index.html")
(find-file-other-frame "~/Dev/ClojureScript/tutorials/my-cljs-project/example-todomvc/resources/public/index.html")

*** style.css
:PROPERTIES:
:header-args: :tangle ./resources/public/css/style.css
:END:
**** file style.css
(find-file-other-frame "./resources/public/css/style.css")
**** src style.css
***** all
#+begin_src css :no-expand t :mkdirp yes 
/* Source: https://github.com/tastejs/todomvc-app-css/blob/v2.1.0/index.css */
html,
body {
    margin: 0;
    padding: 0;
}

button {
    margin: 0;
    padding: 0;
    border: 0;
    background: none;
    font-size: 100%;
    vertical-align: baseline;
    font-family: inherit;
    font-weight: inherit;
    color: inherit;
    -webkit-appearance: none;
    appearance: none;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
}

body {
    font: 14px 'Helvetica Neue', Helvetica, Arial, sans-serif;
    line-height: 1.4em;
    background: #f5f5f5;
    color: #4d4d4d;
    min-width: 230px;
    max-width: 550px;
    margin: 0 auto;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    font-weight: 300;
}

:focus {
    outline: 0;
}

.hidden {
    display: none;
}

.todoapp {
    background: #fff;
    margin: 130px 0 40px 0;
    position: relative;
    box-shadow: 0 2px 4px 0 rgba(0, 0, 0, 0.2),
                0 25px 50px 0 rgba(0, 0, 0, 0.1);
}

.todoapp input::-webkit-input-placeholder {
    font-style: italic;
    font-weight: 300;
    color: #e6e6e6;
}

.todoapp input::-moz-placeholder {
    font-style: italic;
    font-weight: 300;
    color: #e6e6e6;
}

.todoapp input::input-placeholder {
    font-style: italic;
    font-weight: 300;
    color: #e6e6e6;
}

.todoapp h1 {
    position: absolute;
    top: -155px;
    width: 100%;
    font-size: 100px;
    font-weight: 100;
    text-align: center;
    color: rgba(175, 47, 47, 0.15);
    -webkit-text-rendering: optimizeLegibility;
    -moz-text-rendering: optimizeLegibility;
    text-rendering: optimizeLegibility;
}

.new-todo,
.edit {
    position: relative;
    margin: 0;
    width: 100%;
    font-size: 24px;
    font-family: inherit;
    font-weight: inherit;
    line-height: 1.4em;
    border: 0;
    color: inherit;
    padding: 6px;
    border: 1px solid #999;
    box-shadow: inset 0 -1px 5px 0 rgba(0, 0, 0, 0.2);
    box-sizing: border-box;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
}

.new-todo {
    padding: 16px 16px 16px 60px;
    border: none;
    background: rgba(0, 0, 0, 0.003);
    box-shadow: inset 0 -2px 1px rgba(0,0,0,0.03);
}

.main {
    position: relative;
    z-index: 2;
    border-top: 1px solid #e6e6e6;
}

.toggle-all {
    text-align: center;
    border: none; /* Mobile Safari */
    opacity: 0;
    position: absolute;
}

.toggle-all + label {
    width: 60px;
    height: 34px;
    font-size: 0;
    position: absolute;
    top: -52px;
    left: -13px;
    -webkit-transform: rotate(90deg);
    transform: rotate(90deg);
}

.toggle-all + label:before {
    content: '❯';
    font-size: 22px;
    color: #e6e6e6;
    padding: 10px 27px 10px 27px;
}

.toggle-all:checked + label:before {
    color: #737373;
}

.todo-list {
    margin: 0;
    padding: 0;
    list-style: none;
}

.todo-list li {
    position: relative;
    font-size: 24px;
    border-bottom: 1px solid #ededed;
}

.todo-list li:last-child {
    border-bottom: none;
}

.todo-list li.editing {
    border-bottom: none;
    padding: 0;
}

.todo-list li.editing .edit {
    display: block;
    width: 506px;
    padding: 12px 16px;
    margin: 0 0 0 43px;
}

.todo-list li.editing .view {
    display: none;
}

.todo-list li .toggle {
    text-align: center;
    width: 40px;
    /* auto, since non-WebKit browsers doesn't support input styling */
    height: auto;
    position: absolute;
    top: 0;
    bottom: 0;
    margin: auto 0;
    border: none; /* Mobile Safari */
    -webkit-appearance: none;
    appearance: none;
}

.todo-list li .toggle {
    opacity: 0;
}

.todo-list li .toggle + label {
    /*
        Firefox requires `#` to be escaped - https://bugzilla.mozilla.org/show_bug.cgi?id=922433
        IE and Edge requires *everything* to be escaped to render, so we do that instead of just the `#` - https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/7157459/
   ,*/
    background-image: url('data:image/svg+xml;utf8,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2240%22%20height%3D%2240%22%20viewBox%3D%22-10%20-18%20100%20135%22%3E%3Ccircle%20cx%3D%2250%22%20cy%3D%2250%22%20r%3D%2250%22%20fill%3D%22none%22%20stroke%3D%22%23ededed%22%20stroke-width%3D%223%22/%3E%3C/svg%3E');
    background-repeat: no-repeat;
    background-position: center left;
}

.todo-list li .toggle:checked + label {
    background-image: url('data:image/svg+xml;utf8,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2240%22%20height%3D%2240%22%20viewBox%3D%22-10%20-18%20100%20135%22%3E%3Ccircle%20cx%3D%2250%22%20cy%3D%2250%22%20r%3D%2250%22%20fill%3D%22none%22%20stroke%3D%22%23bddad5%22%20stroke-width%3D%223%22/%3E%3Cpath%20fill%3D%22%235dc2af%22%20d%3D%22M72%2025L42%2071%2027%2056l-4%204%2020%2020%2034-52z%22/%3E%3C/svg%3E');
}

.todo-list li label {
    word-break: break-all;
    padding: 15px 15px 15px 60px;
    display: block;
    line-height: 1.2;
    transition: color 0.4s;
}

.todo-list li.completed label {
    color: #d9d9d9;
    text-decoration: line-through;
}

.todo-list li .destroy {
    display: none;
    position: absolute;
    top: 0;
    right: 10px;
    bottom: 0;
    width: 40px;
    height: 40px;
    margin: auto 0;
    font-size: 30px;
    color: #cc9a9a;
    margin-bottom: 11px;
    transition: color 0.2s ease-out;
}

.todo-list li .destroy:hover {
    color: #af5b5e;
}

.todo-list li .destroy:after {
    content: '×';
}

.todo-list li:hover .destroy {
    display: block;
}

.todo-list li .edit {
    display: none;
}

.todo-list li.editing:last-child {
    margin-bottom: -1px;
}

.footer {
    color: #777;
    padding: 10px 15px;
    height: 20px;
    text-align: center;
    border-top: 1px solid #e6e6e6;
}

.footer:before {
    content: '';
    position: absolute;
    right: 0;
    bottom: 0;
    left: 0;
    height: 50px;
    overflow: hidden;
    box-shadow: 0 1px 1px rgba(0, 0, 0, 0.2),
                0 8px 0 -3px #f6f6f6,
                0 9px 1px -3px rgba(0, 0, 0, 0.2),
                0 16px 0 -6px #f6f6f6,
                0 17px 2px -6px rgba(0, 0, 0, 0.2);
}

.todo-count {
    float: left;
    text-align: left;
}

.todo-count strong {
    font-weight: 300;
}

.filters {
    margin: 0;
    padding: 0;
    list-style: none;
    position: absolute;
    right: 0;
    left: 0;
}

.filters li {
    display: inline;
}

.filters li a {
    color: inherit;
    margin: 3px;
    padding: 3px 7px;
    text-decoration: none;
    border: 1px solid transparent;
    border-radius: 3px;
}

.filters li a:hover {
    border-color: rgba(175, 47, 47, 0.1);
}

.filters li a.selected {
    border-color: rgba(175, 47, 47, 0.2);
}

.clear-completed,
html .clear-completed:active {
    float: right;
    position: relative;
    line-height: 20px;
    text-decoration: none;
    cursor: pointer;
}

.clear-completed:hover {
    text-decoration: underline;
}

.info {
    margin: 65px auto 0;
    color: #bfbfbf;
    font-size: 10px;
    text-shadow: 0 1px 0 rgba(255, 255, 255, 0.5);
    text-align: center;
}

.info p {
    line-height: 1;
}

.info a {
    color: inherit;
    text-decoration: none;
    font-weight: 400;
}

.info a:hover {
    text-decoration: underline;
}

/*
    Hack to remove background from Mobile Safari.
    Can't use it globally since it destroys checkboxes in Firefox
,*/
@media screen and (-webkit-min-device-pixel-ratio:0) {
    .toggle-all,
    .todo-list li .toggle {
        background: none;
    }

    .todo-list li .toggle {
        height: 40px;
    }
}

@media (max-width: 430px) {
    .footer {
        height: 50px;
    }

    .filters {
        bottom: 10px;
    }
}
#+end_src
***** /* === Timer Component Styling Fit for TodoMVC === */
#+begin_src css :no-expand t :mkdirp yes 
.todo-list li .timer {
    display: inline-flex;
    align-items: center;
    margin-left: auto; 
}

.todo-list li .timer button {
    font-size: 13px;           
    padding: 7px 13px;         
    background: none;
    border: 2px solid #ccc;
    border-radius: 4px;
    cursor: pointer;
    color: #555;
    transition: all 0.2s ease-out;
}

.todo-list li .timer button:hover {
    background: #eee;
    border-color: #bbb;
    color: #333;
}

/* состояние когда таймер запущен */
.todo-list li .timer.running button {
    background: #27ae60;
    border-color: #1e874b;
    color: #fff;
}

.todo-list li.completed .timer .seconds {
    color: #d9d9d9;
}

.todo-list li .timer .seconds {
    margin-left: 8px;
    font-size: 14px;
    color: #777;
}


#+end_src

**** ИИ
***** довай сделаем стиль
для этих двух элементов.
**** exampl
(find-file-other-frame "~/Dev/ClojureScript/tutorials/my-cljs-project/example-todomvc/resources/public/css/style.css")
**** CANCELED arhiv
:PROPERTIES:
:header-args: :tangle no
:END:
***** 00 /* === Timer Component Styles === */
#+begin_src css :no-expand t :mkdirp yes 

.timer {
    margin: 15px auto;
    padding: 10px;
    text-align: center;
    font-size: 18px;
}

.timer button {
    background: #5dc2af;
    color: #fff;
    border-radius: 4px;
    padding: 6px 14px;
    font-size: 14px;
    cursor: pointer;
    transition: background 0.2s ease-out;
    border: none;
}

.timer button:hover {
    background: #54b2a0;
}

.timer button:active {
    background: #4aa492;
}

.timer .seconds {
    margin-left: 10px;
    font-weight: bold;
    color: #4d4d4d;
}

.timer.running .seconds {
    color: #5dc2af;
}
#+end_src
***** 00 /* === Timer Component Styling Fit for TodoMVC === */
#+begin_src css :no-expand t :mkdirp yes 
.todo-list li .timer {
    display: inline-flex;
    align-items: center;
    margin-left: 10px;
}

.todo-list li .timer button {
    font-size: 12px;
    padding: 3px 6px;
    background: none;
    border: 1px solid #ccc;
    border-radius: 3px;
    cursor: pointer;
    color: #777;
    transition: all 0.2s ease-out;
}

.todo-list li .timer button:hover {
    background: #eee;
    border-color: #bbb;
    color: #555;
}

.todo-list li .timer button:active {
    background: #ddd;
    border-color: #aaa;
    color: #333;
}

.todo-list li .timer .seconds {
    margin-left: 6px;
    font-size: 12px;
    color: #777;
}

.todo-list li.completed .timer .seconds {
    color: #d9d9d9;
}

#+end_src

* files worder
** files core
(find-file-other-frame "./src/keechma_todomvc/app.cljs")
(find-file-other-frame "./src/keechma_todomvc/subscriptions.cljs")
(find-file-other-frame "./src/keechma_todomvc/ui.cljs")
(find-file-other-frame "./src/keechma_todomvc/util.cljs")
(find-file-other-frame "./src/keechma_todomvc/components.cljs")
(find-file-other-frame "./src/keechma_todomvc/edb.cljs")
(find-file-other-frame "./src/keechma_todomvc/edb.clj")
** files components
(find-file-other-frame "./src/keechma_todomvc/components/app.cljs")
(find-file-other-frame "./src/keechma_todomvc/components/new_todo.cljs")
(find-file-other-frame "./src/keechma_todomvc/components/toggle_todos.cljs")
(find-file-other-frame "./src/keechma_todomvc/components/todo_list.cljs")
(find-file-other-frame "./src/keechma_todomvc/components/todo_item.cljs")
(find-file-other-frame "./src/keechma_todomvc/components/todo_edit.cljs")
(find-file-other-frame "./src/keechma_todomvc/components/footer.cljs")
** files controler
(find-file-other-frame "./src/keechma_todomvc/controllers/todos.cljs")
** files entities
(find-file-other-frame "./src/keechma_todomvc/entities/todo.cljs")
** files resurs
(find-file-other-frame "./resources/public/css/style.css")
(find-file-other-frame "./resources/public/index.html")
** files project
(find-file-other-frame "./project.clj")
(find-file-other-frame "./target/stale/leiningen.figwheel.clean-on-dependency-change")
* run worder
*** run
lein figwheel

:cljs/quit
:cljs/restart

#+begin_src elisp :results output silent 
(evil-previous-line)
(org-cycle)
(delete-other-windows)
(let (buffer-name-to-close (buffer-name))
        (evil-window-split)
        (eshell)
        (evil-quit)
        (switch-to-buffer-other-frame buffer-name-to-close))
#+end_src

cd worder
clojure -M:fig:build
clojure -M:fig:build dev

ls 
ls target public/js
ls .cpcache
rm -rf target public/js
rm -rf .cpcache

lein cljsbuild once

lein deps :refresh

*** clon
git clone https://github.com/keechma/example-todomvc.git
* TODO todo worder
** загрузить список слов
*** src
**** file components/app.cljs
(find-file-other-frame "./src/keechma_todomvc/components/app.cljs")
**** src components/app.cljs
#+begin_src clojure :no-expand t :mkdirp yes 
(ns keechma-todomvc.components.app
  "# Main app component"
  (:require [keechma-todomvc.ui :refer [<comp comp> sub>]]))

(defn render
  [ctx]
  [:<>
   [:section.todoapp
    [:header.header
     [:h1 "Worder"]
     [comp> ctx :new-todo]]
    (when (sub> ctx :has-todos?)
      [:<>
       [:section.main
        [comp> ctx :toggle-todos]
        [comp> ctx :todo-list]]
       [comp> ctx :footer]])]
   [:footer.info
    [:p "Double-click to edit a todo"]
    [:p
     [:a {:href "https://keechma.com"} "Keechma"] " "
     [:a {:href "http://todomvc.com"} "TodoMVC"]]]])

(def component
  (<comp :renderer render
         :component-deps [:new-todo
                          :toggle-todos
                          :todo-list
                          :footer]
         :subscription-deps [:has-todos?]))

#+end_src


*** Довай в components/app.cljs сделаем кнопку
разместим под тайтлом Вордер.
она должна просить юзера указать путь к файлу для загрузки.
читать этот фаил. Парсить его контент на строки.
и добовлять каждую строку, как новое туду.

*** План реализации
Супер! Вот как мы можем реализовать такой функционал "загрузки файла → парсинг строк → добавление каждой строки как отдельное todo" для вашего приложения Keechma + Reagent. Я дам **шаг-за-шагом** + код-пример.

---
## 🔍 План реализации

1. Добавить кнопку или инпут `<input type="file">` в компонент.
2. При выборе файла — прочитать его содержимое (FileReader API) ([MDN Web Docs][1]).
3. Разбить содержимое на строки (`.split("\n")`).
4. Для каждой строки вызвать команду контроллера `:create-todo` (или аналог) с этой строкой как заголовок.
5. Опционально: показать пользователю прогресс (например “добавлено N задач”).
6. Обеспечить обработку ошибок (пустой файл, слишком длинные строки и т.д.).

---

## 🧮 Пример компонента: `file-import-button.cljs`

```clojure
(ns keechma-todomvc.components.file-import-button
  (:require [reagent.core :as r]
            [keechma-todomvc.ui :refer [<cmd <comp]]))

(defn render‐import [_ctx]
  (let [file-ref (r/atom nil)]
    (fn []
      [:div.file-import
       [:input {:type "file"
                :accept ".txt"
                :on-change (fn [e]
                             (let [file (-> e .-target .-files (aget 0))]
                               (when file
                                 (let [reader (js/FileReader.)]
                                   (set! (.-onload reader)
                                         (fn [evt]
                                           (let [text (.. evt -target -result)
                                                 lines (.split text "\n")]
                                             (doseq [line lines
                                                     :let [trimmed (clojure.string/trim line)]
                                                     :when (not (clojure.string/blank? trimmed))]
                                               (<cmd _ctx :create-todo trimmed)))))
                                   (.readAsText reader file))))]
        ]
       [:button {:on-click #(when @file-ref (.click @file-ref))}
        "Import todo-file"]])))
```

И регистрация в системе компонентов:

```clojure
;; в components.cljs
:import-todos (assoc file-import-button/component :topic :todos)
```

---

## ✅ Что важно учесть

  * Команда `:create-todo` должна быть реализована и контроллер должен слушать её (у вас уже есть `create-todo`).
  * Убедитесь, что `<cmd _ctx :create-todo trimmed>` правильно передаёт аргумент (в виде строки или map) в контроллер.
  * Обработка файла через `FileReader.readAsText()` работает только для текстовых файлов. ([MDN Web Docs][2])
  * Используйте `clojure.string/trim` и фильтрацию пустых строк — чтобы не создавать задачи с пустым заголовком.
  * Опционально: добавить UI-индикатор загрузки, показать сколько строк добавлено и т.д.

---

Если хочешь — могу подготовить **полный рабочий файл** с CSS-стилями, кнопкой в строке `todo-item` (чтобы он появился рядом с таймером и кнопкой удаления) + интеграцией в контроллер, чтобы всё “из коробки” работало. Сделать?

[1]: https://developer.mozilla.org/en-US/docs/Web/API/File_API/Using_files_from_web_applications?utm_source=chatgpt.com "Using files from web applications - Web APIs | MDN - Mozilla"
[2]: https://developer.mozilla.org/en-US/docs/Web/API/FileReader/readAsText?utm_source=chatgpt.com "FileReader: readAsText() method - Web APIs - MDN Web Docs"


* REPL
:PROPERTIES:
:header-args: :tangle no :mkdirp yes :results output silent :no-expand t
:END:
** start
lein figwheel
clojure -M:fig:build
#+begin_src elisp :results output silent 
(evil-previous-line)
(org-cycle)
(delete-other-windows)
(let (buffer-name-to-close (buffer-name))
        (evil-window-split)
        (eshell)
        (evil-quit)
        (switch-to-buffer-other-frame buffer-name-to-close))
#+end_src
** commans
clojure -M:fig:build
:cljs/quit
:cljs/restart

clojure -M:fig:clean
clojure -M:fig:build
* backlog worder
** старт таймера останавливает остольные
таймеры
так чтоб всегда было не более одного таймера
** переписать текст под слова в интервейсе
добовлем слова вместо туду
видемо вордер
** туду итем комплит делает невозможны запуск таймер
** Авто-стоп, если todo помечен completed
| Авто-стоп, если todo помечен completed        | Логичное UX-поведение 
** понять можно ли оптемизировать атомы
чтоб по остановку таймера освобождались не нужные атомы
они нужны только при старте таймера
** туду итем комплит делает кнопку серой
** помошь уни стиль прижать кнопу в право
** туду итем комплит останавливает таймер
если он запущен в этот момент
** убедится что удаение останваливает таймер

Ещё: чистка таймера при размонтировании

Добавь "cleanup" чтобы не оставлять setInterval висеть, если todo удаляется / компонент размонтируется:

Если используешь form-2, можно в reagent/create-class (form-3) реализовать :component-will-unmount и там js/clearInterval. Или в form-2 — вернуть функцию очистки через reagent.core/create-class — но проще: при остановке или размонтировании явно чисти @timer-id.
** переписать текст под слова в коде
повозможно везде по коду
** добавить кнопки сохранить слова 
возможно только сразу все в текст
с результатами в текстовый фаил
сохранить только завершоные
сохранить только не завершоные
сохронять те что в даный момент отфильтрованы
тоесть кнопка "сохранить активные as .txt"
тоесть либо все либо завершоные либо не завершоные
** добавить кнопки сохранить слова в цсв
возможно только сразу все в цсв
с результатами 
сохранить только завершоные
сохранить только не завершоные
сохронять те что в даный момент отфильтрованы
тоесть кнопка "сохранить активные as .csv"
тоесть либо все либо завершоные либо не завершоные
** сменить цветовую схему
на автоматическую посмотреть что из этого получится
** забилдить для размешения
** захостить
возможно нужна будет помошь Уни
** передать вале
* project comands
:PROPERTIES:
:header-args: :tangle no
:END:
** поиск по проекту
*** 
**** dropbox in org
#+begin_src sh  
grep --include=\*.cljs -rnw ./ -e ":todos-by-status"
#+end_src       

#+RESULTS:
| ./src/keechma_todomvc/components/todo_list.cljs:18:-                     | `:todos-by-status` | returns           | `todos`         | with  | a   | `status`         |                    |
| ./src/keechma_todomvc/components/todo_list.cljs:26:                      | (doall             | (map              | todo-item       | (sub> | ctx | :todos-by-status | route-status)))])) |
| ./src/keechma_todomvc/components/todo_list.cljs:31:                      | :subscription-deps | [:todos-by-status |                 |       |     |                  |                    |
| ./src/keechma_todomvc/subscriptions.cljs:48:(def                         | subscriptions      | {:todos-by-status | todos-by-status |       |     |                  |                    |
| ./resources/public/js/dev/keechma_todomvc/components/todo_list.cljs:18:- | `:todos-by-status` | returns           | `todos`         | with  | a   | `status`         |                    |
| ./resources/public/js/dev/keechma_todomvc/components/todo_list.cljs:26:  | (doall             | (map              | todo-item       | (sub> | ctx | :todos-by-status | route-status)))])) |
| ./resources/public/js/dev/keechma_todomvc/components/todo_list.cljs:31:  | :subscription-deps | [:todos-by-status |                 |       |     |                  |                    |
| ./resources/public/js/dev/keechma_todomvc/subscriptions.cljs:48:(def     | subscriptions      | {:todos-by-status | todos-by-status |       |     |                  |                    |


**** dropbox in org
#+begin_src sh  
grep --include=\*.cljs -rnw ./ -e "reagent.core"
#+end_src       

#+RESULTS:
| ./src/keechma_todomvc/components/new_todo.cljs:5:                          | [reagent.core    | :as             | reagent])) |         |        |           |
| ./target/public/cljs-out/dev/reagent/core.cljs:1:(ns                       | reagent.core     |                 |            |         |        |           |
| ./target/public/cljs-out/dev/reagent/core.cljs:2:                          | (:require-macros | [reagent.core]) |            |         |        |           |
| ./target/public/cljs-out/dev/keechma_todomvc/components/new_todo.cljs:5:   | [reagent.core    | :as             | reagent])) |         |        |           |
| ./target/public/cljs-out/dev/keechma_todomvc/components/todo_edit.cljs:5:  | [reagent.core    | :as             | reagent])) |         |        |           |
| ./target/public/cljs-out/dev/keechma/app_state/react_native_router.cljs:3: | [reagent.core    | :as             | r]         |         |        |           |
| ./target/public/cljs-out/dev/keechma/app_state.cljs:2:                     | (:require        | [reagent.core   | :as        | reagent | :refer | [cursor]] |


** files other
find "$PWD" -type f >>filepath.txt

(find-file-other-frame "./README.md")
(find-file-other-frame "./figwheel_server.log")
** repl
*** run eshell in project root
clojure -M:fig:build
:cljs/quit
:cljs/restart

clj -M:dev
clojure -m cljs.main --compile my-cljs-project.core --repl


clojure -P
clojure -M:fig:clean
clojure -M:fig:build

#+begin_src elisp :results output silent :dir ./notes/
(evil-previous-line)
(org-cycle)
(delete-other-windows)
(let (buffer-name-to-close (buffer-name))
        (evil-window-split)
        (eshell)
        (evil-quit)
        (switch-to-buffer-other-frame buffer-name-to-close))
#+end_src

      ;; (execute-kbd-macro "A \C-m")
*** run eshell in org root
clj -M:dev
clojure -m cljs.main --compile my-cljs-project.core --repl
#+begin_src elisp :results output silent
(evil-previous-line)
(org-cycle)
(delete-other-windows)
(let (buffer-name-to-close (buffer-name))
        (evil-window-split)
        (eshell)
        (evil-quit)
        (switch-to-buffer-other-frame buffer-name-to-close))
#+end_src

      ;; (execute-kbd-macro "A \C-m")
*** run repl
clj -M:dev
clojure -m cljs.main --compile my-cljs-project.core --repl

clojure -M:fig:build
:cljs/quit
:cljs/restart
#+begin_src eshell
clj -m cljs.main --compile my-cljs-project.core --repl


#+end_src

#+RESULTS:
*** repl commands
:cljs/quit
*** repl test
(js/alert "Am I connected?")
** new project
clj -X:new :template figwheel-main :name learn-cljs/notes :args '["+deps" "--reagent"]'

{:deps {org.clojure/clojure {:mvn/version "1.10.0"}
        org.clojure/clojurescript {:mvn/version "1.10.773"}
        reagent/reagent {:mvn/version "1.0.0"}
        funcool/bide {:mvn/version "1.6.0"}
        camel-snake-kebab/camel-snake-kebab {:mvn/version "0.4.2"}}

$ clj -X:new :template figwheel-main :name learn-cljs/weather :args 
[[file:~/Dropbox/orgs/org-Brain/ClojureScript Idioms.org::*2025-09-04T11:12:30+03:00][2025-09-04T11:12:30+03:00]]
** cider
If you have a Clojure project in your file system and want CIDER to launch an nREPL session for it, simply visit a file that belongs to the project, and type M-x cider-jack-in RET.[1] CIDER will start an nREPL server and automatically connect to it.
  In Clojure(Script) buffers the command cider-jack-in is bound to C-c C-x (C-)j (C-)j. 

** console
*** run console in org root
clj -M:dev
clojure -m cljs.main --compile my-cljs-project.core --repl
#+begin_src elisp :results output silent
(buyn-shell-start "konsole")
(evil-previous-line)
(org-cycle)
(delete-other-windows)
#+end_src

*** run console with command
#+begin_src elisp :results output silent
(buyn-shell-start "konsole -e /bin/bash --rcfile <(clj -M:dev)")
(evil-previous-line)
(org-cycle)
(delete-other-windows)
#+end_src

** auto-tangle-block:
#+NAME: auto-tangle-block
#+begin_src emacs-lisp :results output silent :tangle no
(setq org-src-preserve-indentation t)
(untabify (point-min) (point-max))
(save-buffer)
;; (universal-argument)
;; (universal-argument)
(org-babel-tangle)
;; (find-file-other-frame "reagent-test/src/learn_cljs/reagent_test.cljs")
;; (find-file-other-frame "~/INI/hydra-cfg.el")
;; (load "~/INI/hydra-cfg.el")
;; (load "~/ELs/BuYn/reader.el")
 #+end_src
* DONE Done worder
** DONE сделать стиль под туду итемс
*** 1
они должны быть в одну строку с тайтлом и кнопки удаления туду
*** src
**** file components/todo_item.cljs
(find-file-other-frame "./src/keechma_todomvc/components/todo_item.cljs")
**** src components/todo_item.cljs
#+begin_src clojure :no-expand t :mkdirp yes 
(ns keechma-todomvc.components.todo-item
  "# Todo Item component"
  (:require [keechma-todomvc.ui :refer [<cmd <comp comp>]]))

(defn render
  [ctx todo is-editing?]
  [:li {:class [(when is-editing? :editing)
                (when (:completed todo) :completed)]}
   [:div.view {:on-double-click #(<cmd ctx :start-edit todo)}
    [:input.toggle {:type :checkbox
                    :checked (:completed todo)
                    :on-change #(<cmd ctx :toggle-todo todo)}]
    [:label (:title todo)]
    [comp> ctx :timer-button]
    [:button.destroy {:on-click #(<cmd ctx :delete-todo todo)}]]
   (when is-editing?
     [comp> ctx :todo-edit])])

(def component
  (<comp :renderer render
         :component-deps [:todo-edit
                          :timer-button]))

#+end_src
     
**** file timer_button.cljs
(find-file-other-frame "./src/keechma_todomvc/components/timer_button.cljs")
**** src timer_button.cljs
#+begin_src clojure :no-expand t :mkdirp yes 
(ns keechma-todomvc.components.timer-button
  (:require [keechma-todomvc.ui :refer [<comp comp> sub>]]
            [reagent.core :as r]))

(defn render [_ctx]
  (let [seconds (r/atom 0)
        timer-id (r/atom nil)
        start-ms (r/atom nil)
        counter (fn [] (reset! seconds (/ (- (.now js/Date) @start-ms) 1000)))
        stop! (fn []
                (counter)
                (js/clearInterval @timer-id)
                (reset! timer-id nil)
                (reset! start-ms nil))
        start! (fn []
                  (reset! start-ms (.now js/Date))
                  (reset! timer-id (js/setInterval counter 100)))
        toggle! (fn [_] (if @timer-id (stop!) (start!)))]  
    (fn []
      [:div.timer
       [:button
        {:on-click toggle!} 
        (if @timer-id "■ Stop" "▶ Start")]
       [:span.seconds (str @seconds " sec")]])))

(def component
  (<comp :renderer render))
#+end_src
**** file style.css
(find-file-other-frame "./resources/public/css/style.css")
**** src style.css
***** all
#+begin_src css :no-expand t :mkdirp yes 
/* Source: https://github.com/tastejs/todomvc-app-css/blob/v2.1.0/index.css */
html,
body {
    margin: 0;
    padding: 0;
}

button {
    margin: 0;
    padding: 0;
    border: 0;
    background: none;
    font-size: 100%;
    vertical-align: baseline;
    font-family: inherit;
    font-weight: inherit;
    color: inherit;
    -webkit-appearance: none;
    appearance: none;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
}

body {
    font: 14px 'Helvetica Neue', Helvetica, Arial, sans-serif;
    line-height: 1.4em;
    background: #f5f5f5;
    color: #4d4d4d;
    min-width: 230px;
    max-width: 550px;
    margin: 0 auto;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    font-weight: 300;
}

:focus {
    outline: 0;
}

.hidden {
    display: none;
}

.todoapp {
    background: #fff;
    margin: 130px 0 40px 0;
    position: relative;
    box-shadow: 0 2px 4px 0 rgba(0, 0, 0, 0.2),
                0 25px 50px 0 rgba(0, 0, 0, 0.1);
}

.todoapp input::-webkit-input-placeholder {
    font-style: italic;
    font-weight: 300;
    color: #e6e6e6;
}

.todoapp input::-moz-placeholder {
    font-style: italic;
    font-weight: 300;
    color: #e6e6e6;
}

.todoapp input::input-placeholder {
    font-style: italic;
    font-weight: 300;
    color: #e6e6e6;
}

.todoapp h1 {
    position: absolute;
    top: -155px;
    width: 100%;
    font-size: 100px;
    font-weight: 100;
    text-align: center;
    color: rgba(175, 47, 47, 0.15);
    -webkit-text-rendering: optimizeLegibility;
    -moz-text-rendering: optimizeLegibility;
    text-rendering: optimizeLegibility;
}

.new-todo,
.edit {
    position: relative;
    margin: 0;
    width: 100%;
    font-size: 24px;
    font-family: inherit;
    font-weight: inherit;
    line-height: 1.4em;
    border: 0;
    color: inherit;
    padding: 6px;
    border: 1px solid #999;
    box-shadow: inset 0 -1px 5px 0 rgba(0, 0, 0, 0.2);
    box-sizing: border-box;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
}

.new-todo {
    padding: 16px 16px 16px 60px;
    border: none;
    background: rgba(0, 0, 0, 0.003);
    box-shadow: inset 0 -2px 1px rgba(0,0,0,0.03);
}

.main {
    position: relative;
    z-index: 2;
    border-top: 1px solid #e6e6e6;
}

.toggle-all {
    text-align: center;
    border: none; /* Mobile Safari */
    opacity: 0;
    position: absolute;
}

.toggle-all + label {
    width: 60px;
    height: 34px;
    font-size: 0;
    position: absolute;
    top: -52px;
    left: -13px;
    -webkit-transform: rotate(90deg);
    transform: rotate(90deg);
}

.toggle-all + label:before {
    content: '❯';
    font-size: 22px;
    color: #e6e6e6;
    padding: 10px 27px 10px 27px;
}

.toggle-all:checked + label:before {
    color: #737373;
}

.todo-list {
    margin: 0;
    padding: 0;
    list-style: none;
}

.todo-list li {
    position: relative;
    font-size: 24px;
    border-bottom: 1px solid #ededed;
}

.todo-list li:last-child {
    border-bottom: none;
}

.todo-list li.editing {
    border-bottom: none;
    padding: 0;
}

.todo-list li.editing .edit {
    display: block;
    width: 506px;
    padding: 12px 16px;
    margin: 0 0 0 43px;
}

.todo-list li.editing .view {
    display: none;
}

.todo-list li .toggle {
    text-align: center;
    width: 40px;
    /* auto, since non-WebKit browsers doesn't support input styling */
    height: auto;
    position: absolute;
    top: 0;
    bottom: 0;
    margin: auto 0;
    border: none; /* Mobile Safari */
    -webkit-appearance: none;
    appearance: none;
}

.todo-list li .toggle {
    opacity: 0;
}

.todo-list li .toggle + label {
    /*
        Firefox requires `#` to be escaped - https://bugzilla.mozilla.org/show_bug.cgi?id=922433
        IE and Edge requires *everything* to be escaped to render, so we do that instead of just the `#` - https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/7157459/
   */
    background-image: url('data:image/svg+xml;utf8,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2240%22%20height%3D%2240%22%20viewBox%3D%22-10%20-18%20100%20135%22%3E%3Ccircle%20cx%3D%2250%22%20cy%3D%2250%22%20r%3D%2250%22%20fill%3D%22none%22%20stroke%3D%22%23ededed%22%20stroke-width%3D%223%22/%3E%3C/svg%3E');
    background-repeat: no-repeat;
    background-position: center left;
}

.todo-list li .toggle:checked + label {
    background-image: url('data:image/svg+xml;utf8,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2240%22%20height%3D%2240%22%20viewBox%3D%22-10%20-18%20100%20135%22%3E%3Ccircle%20cx%3D%2250%22%20cy%3D%2250%22%20r%3D%2250%22%20fill%3D%22none%22%20stroke%3D%22%23bddad5%22%20stroke-width%3D%223%22/%3E%3Cpath%20fill%3D%22%235dc2af%22%20d%3D%22M72%2025L42%2071%2027%2056l-4%204%2020%2020%2034-52z%22/%3E%3C/svg%3E');
}

.todo-list li label {
    word-break: break-all;
    padding: 15px 15px 15px 60px;
    display: block;
    line-height: 1.2;
    transition: color 0.4s;
}

.todo-list li.completed label {
    color: #d9d9d9;
    text-decoration: line-through;
}

.todo-list li .destroy {
    display: none;
    position: absolute;
    top: 0;
    right: 10px;
    bottom: 0;
    width: 40px;
    height: 40px;
    margin: auto 0;
    font-size: 30px;
    color: #cc9a9a;
    margin-bottom: 11px;
    transition: color 0.2s ease-out;
}

.todo-list li .destroy:hover {
    color: #af5b5e;
}

.todo-list li .destroy:after {
    content: '×';
}

.todo-list li:hover .destroy {
    display: block;
}

.todo-list li .edit {
    display: none;
}

.todo-list li.editing:last-child {
    margin-bottom: -1px;
}

.footer {
    color: #777;
    padding: 10px 15px;
    height: 20px;
    text-align: center;
    border-top: 1px solid #e6e6e6;
}

.footer:before {
    content: '';
    position: absolute;
    right: 0;
    bottom: 0;
    left: 0;
    height: 50px;
    overflow: hidden;
    box-shadow: 0 1px 1px rgba(0, 0, 0, 0.2),
                0 8px 0 -3px #f6f6f6,
                0 9px 1px -3px rgba(0, 0, 0, 0.2),
                0 16px 0 -6px #f6f6f6,
                0 17px 2px -6px rgba(0, 0, 0, 0.2);
}

.todo-count {
    float: left;
    text-align: left;
}

.todo-count strong {
    font-weight: 300;
}

.filters {
    margin: 0;
    padding: 0;
    list-style: none;
    position: absolute;
    right: 0;
    left: 0;
}

.filters li {
    display: inline;
}

.filters li a {
    color: inherit;
    margin: 3px;
    padding: 3px 7px;
    text-decoration: none;
    border: 1px solid transparent;
    border-radius: 3px;
}

.filters li a:hover {
    border-color: rgba(175, 47, 47, 0.1);
}

.filters li a.selected {
    border-color: rgba(175, 47, 47, 0.2);
}

.clear-completed,
html .clear-completed:active {
    float: right;
    position: relative;
    line-height: 20px;
    text-decoration: none;
    cursor: pointer;
}

.clear-completed:hover {
    text-decoration: underline;
}

.info {
    margin: 65px auto 0;
    color: #bfbfbf;
    font-size: 10px;
    text-shadow: 0 1px 0 rgba(255, 255, 255, 0.5);
    text-align: center;
}

.info p {
    line-height: 1;
}

.info a {
    color: inherit;
    text-decoration: none;
    font-weight: 400;
}

.info a:hover {
    text-decoration: underline;
}

/*
    Hack to remove background from Mobile Safari.
    Can't use it globally since it destroys checkboxes in Firefox
*/
@media screen and (-webkit-min-device-pixel-ratio:0) {
    .toggle-all,
    .todo-list li .toggle {
        background: none;
    }

    .todo-list li .toggle {
        height: 40px;
    }
}

@media (max-width: 430px) {
    .footer {
        height: 50px;
    }

    .filters {
        bottom: 10px;
    }
}
#+end_src
***** /* === Timer Component Styles === */
#+begin_src css :no-expand t :mkdirp yes 

.timer {
    margin: 15px auto;
    padding: 10px;
    text-align: center;
    font-size: 18px;
}

.timer button {
    background: #5dc2af;
    color: #fff;
    border-radius: 4px;
    padding: 6px 14px;
    font-size: 14px;
    cursor: pointer;
    transition: background 0.2s ease-out;
    border: none;
}

.timer button:hover {
    background: #54b2a0;
}

.timer button:active {
    background: #4aa492;
}

.timer .seconds {
    margin-left: 10px;
    font-weight: bold;
    color: #4d4d4d;
}

.timer.running .seconds {
    color: #5dc2af;
}
#+end_src

*** довай изменим стиль для компонента button timer
чтоб он больше отражал стиль туду имов часть которых он явлется
они должны быть в одну строку с тайтлом и кнопки удаления туду
** DONE добавить цет при активаци
[:div.timer {:class (when running? "running")}
 [:button {:on-click toggle!} (if running? "■" "▶")}
 [:span.seconds @seconds]]

** DONE добавить сохрание перменной в туду
*** 1
тоесть в главную перменную приложения как свойство каждого туду
💾 сохранение времени в edb (привязать к todo-id)
*** src
**** file timer_button.cljs
(find-file-other-frame "./src/keechma_todomvc/components/timer_button.cljs")
**** src timer_button.cljs
#+begin_src clojure :no-expand t :mkdirp yes 
(ns keechma-todomvc.components.timer-button
  (:require [keechma-todomvc.ui :refer [<comp comp> sub>]]
            [reagent.core :as r]))

(defn render [_ctx]
  (let [seconds (r/atom 0)
        timer-id (r/atom nil)
        start-ms (r/atom nil)
        running? (fn [](not (= @timer-id nil)))
        counter (fn [] (reset! seconds (/ (- (.now js/Date) @start-ms) 1000)))
        stop! (fn []
                (counter)
                (js/clearInterval @timer-id)
                (reset! timer-id nil)
                (reset! start-ms nil))
        start! (fn []
                  (reset! start-ms (.now js/Date))
                  (reset! timer-id (js/setInterval counter 100)))
        toggle! (fn [_] (if (running?) (stop!) (start!)))]  
    (fn []
      [:div.timer {:class (when (running?) "running")}
       [:button
        {:on-click toggle!} 
        (if (running?) "■ Stop" "▶ Start")]
       [:span.seconds (str @seconds " sec")]])))

(def component
  (<comp :renderer render))
#+end_src
*** да довай добавим
чтоб при срабатывании stop!
происходило сохранение окончательного значения секунд в edb (привязать к todo-id)
*** ИИ
Отлично — давай сделаем это правильно и «по-кеччмовски» ✅
Если хотим **сохранять итоговое время в EDB**, компоненту надо знать **todo-id** и вызывать **cmd**.

---

## ✅ Что нужно добавить:

1️⃣ В рендер передать `todo` (минимум `id`)
2️⃣ На `stop!` вызвать `( <cmd ctx :save-timer-time {:id id :seconds @seconds} )`
3️⃣ В `controllers/todos.cljs` добавить обработку этого `:save-timer-time`
4️⃣ В `entitydb` хранить новое поле, например `:timer-sec`

---

## ✅ Обновлённый компонент: timer_button.cljs

> ✅ Компонент теперь ожидает todo как второй аргумент

```clojure
(ns keechma-todomvc.components.timer-button
  (:require [keechma-todomvc.ui :refer [<comp <cmd sub>]]
            [reagent.core :as r]))

(defn render [ctx todo]
  (let [id (:id todo)
        seconds (r/atom 0)
        timer-id (r/atom nil)
        start-ms (r/atom nil)

        running? #(some? @timer-id)

        counter #(reset! seconds (/ (- (.now js/Date) @start-ms) 1000))

        save! #(when id
                 (<cmd ctx :save-timer-time {:id id
                                             :timer-sec @seconds}))

        stop! (fn []
                (counter)
                (js/clearInterval @timer-id)
                (reset! timer-id nil)
                (reset! start-ms nil)
                (save!))

        start! #(do (reset! start-ms (.now js/Date))
                    (reset! timer-id (js/setInterval counter 100)))

        toggle! (fn [_]
                  (if (running?) (stop!) (start!)))]

    (fn [_ctx _todo] ;; <- rerender fn
      [:div.timer {:class (when (running?) "running")}
       [:button {:on-click toggle!}
        (if (running?) "■ Stop" "▶ Start")]
       [:span.seconds (str (int @seconds) " sec")]])))

(def component
  (<comp :renderer render
         :subscription-deps []))
```

---

## ✅ Контроллер: сохранение в edb

В `keechma-todomvc.controllers.todos` добавляем:

```clojure
(defmethod cmd :save-timer-time
  [_ _ {:keys [id timer-sec] :as payload}]
  (fn [app-db]
    (if id
      (edb/insert-item app-db :todos (assoc payload :id id))
      app-db)))
```

> 🔹 Мы обновляем item todo в EDB, добавляя поле `:timer-sec`
> 🔹 Можно потом использовать его в UI

---

## ✅ Передача timer button в todo-item

В `todo_item.cljs` изменяем:

```clojure
[:label (:title todo)]
[comp> ctx :timer-button todo]
```

Важно: компоненту нужно **знать `todo-id`**, иначе сохранять нечего.

---

## ✅ Доп. улучшения, если хочешь:

| Опция                                         | Эффект                |
| --------------------------------------------- | --------------------- |
| Автозагрузка сохранённого времени при рендере | Таймер помнит историю |
| Авто-стоп, если todo помечен completed        | Логичное UX-поведение |
| Подсветка таймера при работе                  | Анимация              |
| Отправка данных на backend                    | Аналитика времени     |

---

Если ты хочешь — сделаем:

✅ отображение сохранённого времени (если таймер уже останавливался)
✅ обнуление при `cancel-edit` или удалении todo
✅ фильтрацию списка по таймеру (например, longest todo first)

---

### Хочешь next step?

Сделаем так, чтобы:

✔ При перезапуске таймера он **продолжал**, а не сбрасывал время
✔ Значение сохранялось **каждые N секунд** автоматом
✔ При navigate/refresh время **восстанавливалось**

---

Хочешь таймер превратить в **мини-POMODORO** в TodoMVC? ⏱🔥
*** :on-change #(<cmd ctx :toggle-todo todo)}]
*** src
**** file components.cljs
(find-file-other-frame "./src/keechma_todomvc/components.cljs")
**** src components.cljs
#+begin_src clojure :no-expand t :mkdirp yes
(ns keechma-todomvc.components
  "# Todo UI Component system"
  (:require [keechma-todomvc.components.app :as app]
            [keechma-todomvc.components.footer :as footer]
            [keechma-todomvc.components.new-todo :as new-todo]
            [keechma-todomvc.components.todo-edit :as todo-edit]
            [keechma-todomvc.components.timer-button :as timer-button]
            [keechma-todomvc.components.todo-item :as todo-item]
            [keechma-todomvc.components.todo-list :as todo-list]
            [keechma-todomvc.components.toggle-todos :as toggle-todos]))

(def system
  "Defines the component `system`. All the components that send commands
  are configured to send them to the `:todos` topic controller."
  {:main app/component
   :footer (assoc footer/component :topic :todos)
   :new-todo (assoc new-todo/component :topic :todos)
   :todo-edit (assoc todo-edit/component :topic :todos)
   :todo-item (assoc todo-item/component :topic :todos)
   :timer-button (assoc timer-button/component :topic :todos)
   :todo-list todo-list/component
   :toggle-todos (assoc toggle-todos/component :topic :todos)})


#+end_src
**** file components/todo_item.cljs
(find-file-other-frame "./src/keechma_todomvc/components/todo_item.cljs")
**** src components/todo_item.cljs
#+begin_src clojure :no-expand t :mkdirp yes 
(ns keechma-todomvc.components.todo-item
  "# Todo Item component"
  (:require [keechma-todomvc.ui :refer [<cmd <comp comp>]]))

(defn render
  [ctx todo is-editing?]
  [:li {:class [(when is-editing? :editing)
                (when (:completed todo) :completed)]}
   [:div.view {:on-double-click #(<cmd ctx :start-edit todo)}
    [:input.toggle {:type :checkbox
                    :checked (:completed todo)
                    :on-change #(<cmd ctx :toggle-todo todo)}]
    [:label (:title todo)
      [comp> ctx :timer-button todo]]
    [:button.destroy {:on-click #(<cmd ctx :delete-todo todo)}]]
   (when is-editing?
     [comp> ctx :todo-edit])])

(def component
  (<comp :renderer render
         :component-deps [:todo-edit
                          :timer-button]))

#+end_src
     
**** file entities/todo.cljs
(find-file-other-frame "./src/keechma_todomvc/entities/todo.cljs")
**** src entities/todo.cljs
#+begin_src clojure :no-expand t :mkdirp yes 
(ns keechma-todomvc.entities.todo
  "# Todo Entities"
  (:require [clojure.string :as str]
            [keechma-todomvc.edb :as edb])
  (:import [goog.ui IdGenerator]))

;; ## Helpers

(def id-generator (IdGenerator.))

(defn id
  "Returns a unique ID for a new todo."
  []
  (.getNextUniqueId id-generator))

(defn valid-title?
  "Returns `true` if `title` is a valid `todo` title."
  [title]
  (not (str/blank? title)))

;; ## Subscription Support (Read)

(defn todos-by-status
  "Returns all `todos` with a `status`."
  [app-db status]
  (let [todos (edb/get-collection app-db :todos :list)]
    (case status
      :completed (filter :completed todos)
      :active (filter (complement :completed) todos)
      :all todos)))

(defn edit-todo
  "Returns the `todo` currently being edited."
  [app-db]
  (->> (get-in app-db [:kv :editing-id])
       (edb/get-item-by-id app-db :todos)))

;; ## Action Support (Write)

;; ### Edit Management

(defn start-edit
  "Sets state: this `todo` is currently being edited."
  [app-db {:keys [id] :as todo}]
  (assoc-in app-db [:kv :editing-id] id))

(defn cancel-edit
  "Clears state: no `todo` is currently being edited."
  [app-db]
  (assoc-in app-db [:kv :editing-id] nil))

(defn confirm-edit
  "Updates `todo` if `new-todo` has a valid `title`."
  [app-db {:keys [id title] :as new-todo}]
  (assert id)
  (if (valid-title? title)
    (-> app-db
        (cancel-edit)
        (edb/insert-item :todos new-todo))
    app-db))

;; ### Create, Update, Delete Todos

(defn create-todos
  "Creates an empty `todos` list."
  [app-db]
  (edb/insert-collection app-db :todos :list []))

(defn create-todo
  "If `title` is valid, creates a new `todo` and inserts it at the
  beginning of the `todo` list."
  [app-db title]
  (if (valid-title? title)
    (let [todo {:id (str "todo" (id))
                :completed false
                :title title}]
      (edb/prepend-collection app-db :todos :list [todo]))
    app-db))

(defn update-todo
  "Merges new data into a `todo`. `patch-todo` must have an `:id`
  value that is the `id` of the `todo` to be updated."
  [app-db {:keys [id] :as patch-todo}]
  (assert id)
  (edb/insert-item app-db :todos patch-todo))


(defn update-todo-time
  [app-db {:keys [id] :as patch-todo} time]
  ;; (assert id)
  ;; (println patch-todo)
  ;; (println time)
  (println "test!")
  ;; сохранить time внутри туду
  ;; и новерно вызвать update-todo
  )

(defn toggle-todo
  "Toggles the `:completed` status of a saved `todo`."
  [app-db todo]
  (update-todo app-db (update todo :completed not)))

(defn toggle-all
  "Marks all `todos` as completed or not based on `completed?`."
  [app-db completed?]
  (reduce (fn [acc todo]
            (update-todo acc (assoc todo :completed completed?)))
          app-db
          (todos-by-status app-db :all)))

(defn delete-todo
  "Removes a `todo` from the EntityDB."
  [app-db {:keys [id] :as todo}]
  (edb/remove-item app-db :todos id))

(defn delete-completed
  "Removes all completed `todos` from the EntityDB."
  [app-db]
  (reduce (fn [acc {:keys [id]}]
            (edb/remove-item acc :todos id))
          app-db
          (todos-by-status app-db :completed)))

;; ## Actions for keechma.controllers/dispatcher

(defn actions
  "Returns a mapping from `todo` topic `command` keywords to `action`
  functions. The mapping is suitable for use by
  `keechma.controller/dispatcher`.

  Adapts the calling convention from the one used by
  `keechma.controllers/dispatcher`:

  `(action-fn app-db-atom args-vec)`

  to one that is more natural for ClojureScript:

  `(handler app-db-atom arg1 arg2 arg3 ...)`.

  Combined with `<cmd` in `ui.cljs`, this allows natural-looking
  arguments in calls to `<cmd` to be handled by a handler with a
  natural looking argument vector in its definition. This insulates
  app developers from the restriction against varags in protocol
  functions that results in `keechma.ui-component/send-command`
  supporting only exactly 2 or 3 args, the last one an optional
  explicit vector of additional args.

  The adapter also provides the side-effect of updating the `app-db`
  with the result of each call, allowing the handlers to be written
  and tested as pure functions that return the new `app-db` value."
  []
  (let [cmd-handlers {:start-edit start-edit
                      :cancel-edit cancel-edit
                      :confirm-edit confirm-edit
                      :create-todo create-todo
                      :delete-todo delete-todo
                      :toggle-todo toggle-todo
                      :toggle-all toggle-all
                      :update-todo-time update-todo-time
                      :delete-completed delete-completed}
        action-adapter (fn [f]
                         (fn [app-db args]
                           (apply swap! app-db f args)))]
    (reduce-kv (fn [acc k f]
                 (assoc acc k (action-adapter f)))
               {}
               cmd-handlers)))

#+end_src
     
**** file components/todo_item.cljs
(find-file-other-frame "./src/keechma_todomvc/components/todo_item.cljs")
**** src components/todo_item.cljs
#+begin_src clojure :no-expand t :mkdirp yes 
(ns keechma-todomvc.components.todo-item
  "# Todo Item component"
  (:require [keechma-todomvc.ui :refer [<cmd <comp comp>]]))

(defn render
  "## Renders a todo list item

  The item's content includes:

- a `checkbox` for toggling `:completed`
- a `label` displaying the `:title`
- a `button` to delete the item

If the item is currently being edited, overlays a `todo-edit` component.

### Component Deps

- `:todo-edit` presents ui to edit a `todo`'s title

### Arguments

  This render function has arguments in addition to `ctx`. Values for
  those are provided at the site where this component is included
  within another, in this case `:todo-list`. If this were a `form-2`
  render function, the returned function would have only `todo` and
  `is-editing?` as arguments."
  [ctx todo is-editing?]
  [:li {:class [(when is-editing? :editing)
                (when (:completed todo) :completed)]}
   [:div.view {:on-double-click #(<cmd ctx :start-edit todo)}
    [:input.toggle {:type :checkbox
                    :checked (:completed todo)
                    :on-change #(<cmd ctx :toggle-todo todo)}]
    [:label (:title todo)
      [comp> ctx :timer-button todo]]
    [:button.destroy {:on-click #(<cmd ctx :delete-todo todo)}]]
   (when is-editing?
     [comp> ctx :todo-edit])])

(def component
  (<comp :renderer render
         :component-deps [:todo-edit
                          :timer-button]))

#+end_src
     
*** что-то update-todo-time уменя неработает
должно при срабатывании stop!
происходило сохранение окончательного значения секунд в edb (привязаное к todo-id)
но функция вызвается. при нажатии стоп я получаю я получаю ожидаемы тест

test! client.cljs:39:18
Trying to send command to a controller that is not running 
Object { meta: null, cnt: 3, arr: (6) […], __hash: null, "cljs$lang$protocol_mask$partition0$": 16647951, "cljs$lang$protocol_mask$partition1$": 139268 }
controller_manager.cljs:27:16
в консоли браузера
Что я делаю нетак?
и предложи рабочую версию update-todo-time выполняюших сохранение

** DONE запустить копию
убедится в работо способности
** DONE перенести в орг нужные файла для работы
взять как миннимум один фаил что убедить в работоспособности механизма
** DONE сделать комит
** CANCELED переделать под фигвилл маин
*** перенести в делейт
*** сделать темплат
clj -X:new :template figwheel-main :name keechma-todomvc/worder :args '["+deps" "--reagent"]'
clj -X:new :template figwheel-main :name worder/keechma-todomvc :args '["+deps" "--reagent"]'
*** через темплат
Переделать **Leiningen + figwheel** → **deps.edn + figwheel-main** — можно ✅
Но **автоматического конвертера** project.clj → deps.edn **не существует**.
Lein и deps используют **разные экосистемы**, поэтому часть настроек придётся переносить вручную.

---

## ✅ Самый простой путь — да:

> Создать новый проект под Figwheel Main и **перенести только код**

Это **гарантированно** даст рабочую конфигурацию без борьбы со сборкой.

---

Но если хочешь — давай сделаем **конвертацию "правильно"** 💪
Вот точный план для твоего проекта.

---

# ✅ deps.edn для твоего TodoMVC на Keechma

Создаём файл: `deps.edn`

```clojure
{:paths ["src" "resources"]

 :deps {org.clojure/clojure        {:mvn/version "1.10.1"}
        org.clojure/clojurescript  {:mvn/version "1.10.597"}
        org.clojure/core.async     {:mvn/version "0.7.559"
                                    :exclusions  [org.clojure/tools.reader]}
        reagent/reagent            {:mvn/version "0.9.1"}
        keechma/keechma            {:mvn/version "0.3.14"
                                    :exclusions [cljsjs/react-with-addons
                                                 cljsjs/react-dom
                                                 cljsjs/react-dom-server]}
        keechma/entitydb           {:mvn/version "0.1.6"}}

 :aliases
 {:fig {:extra-deps
        {com.bhauman/figwheel-main {:mvn/version "0.2.18"}
         com.bhauman/rebel-readline-cljs {:mvn/version "0.1.4"}}
        :main-opts ["-m" "figwheel.main"]}}}
```

---

## ✅ Конфиг Figwheel Main

Создай файл: `figwheel-main.edn`

```clojure
{:watch-dirs ["src"]
 :css-dirs   ["resources/public/css"]}
```

---

## ✅ Build config (вместо :cljsbuild)

Создай: `dev.cljs.edn`

```clojure
{:main keechma-todomvc.app
 :output-to "resources/public/js/app.js"
 :output-dir "resources/public/js/dev"
 :asset-path "js/dev"
 :closure-defines {goog.DEBUG true}
 :preloads [devtools.preload]}
```

И production build:

`prod.cljs.edn`:

```clojure
{:main keechma-todomvc.app
 :optimizations :advanced
 :output-to "resources/public/js/app.js"
 :output-dir "resources/public/js/min"
 :closure-defines {goog.DEBUG false}}
```

---

## ✅ Запуск

Dev mode (аналог `lein figwheel`):

```bash
clojure -M:fig:build dev
```

Prod build:

```bash
clojure -M:fig:build prod
```

---

# 🧠 Сравнение подходов

| Способ                            | Плюсы                       | Минусы                                 |
| --------------------------------- | --------------------------- | -------------------------------------- |
| ✅ Новый проект + перенос кода     | Быстро, чисто, современно   | Нужно переносить руками                |
| 🛠 Конвертация вручную (как выше) | Сохраняем структуру проекта | Нужно разбираться в deps+figwheel-main |
| ❌ Авто-конвертер                  | —                           | Его не существует                      |

---

## 🎁 Хочешь — я могу сделать всё за тебя 💅

Я могу:
✅ Сгенерировать эталонный figwheel-main проект
✅ Переместить твои файлы
✅ Проверить запуск
✅ Помочь добавить live reload HTML, REPL, nREPL, Shadow готовый переход

Только скажи, как ты хочешь назвать новый проект 💬

Например:

```
keechma-todomvc-main
```

Хочешь — сделаю PR-style diff, чтобы было видно все изменения ✅

Продолжаем? 😎

*** ИИ
у меня есть проект под lein figwheel
(find-file-other-frame "./project.clj")
(defproject keechma-todomvc "0.1.0-SNAPSHOT"
  :description "TodoMVC implemented in Keechma"
  :url "http://github.com/keechma/keechma-todomvc"
  :license {:name "MIT"}

  :min-lein-version "2.5.3"

  :dependencies [[org.clojure/clojure "1.10.1"]
                 [org.clojure/clojurescript "1.10.597"]
                 [org.clojure/core.async "0.7.559"
                  :exclusions [org.clojure/tools.reader]]
                 [reagent "0.9.1"]
                 [keechma "0.3.14"
                  :exclusions [cljsjs/react-with-addons
                               cljsjs/react-dom
                               cljsjs/react-dom-server]]
                 [keechma/entitydb "0.1.6"]]

  :plugins [[lein-figwheel "0.5.19"]
            [lein-cljsbuild "1.1.7"
             :exclusions [[org.clojure/clojure]]]
            [lein-marginalia "0.9.1"]]

  :source-paths ["src"]

  :clean-targets ^{:protect false} ["resources/public/js/compiled" "target"]

  :cljsbuild
  {:builds
   [{:id "dev"
     :source-paths ["src"]
     :figwheel {:on-jsload "keechma-todomvc.app/restart!"}
     :compiler {:main                 keechma-todomvc.app
                :optimizations        :none
                :output-to            "resources/public/js/app.js"
                :output-dir           "resources/public/js/dev"
                :asset-path           "js/dev"
                :source-map-timestamp true}}
    ;; This next build is an compressed minified build for
    ;; production. You can build this with:
    ;; lein cljsbuild once min
    {:id "min"
     :source-paths ["src"]
     :compiler {:main            keechma-todomvc.app
                :optimizations   :advanced
                :output-to       "resources/public/js/app.js"
                :output-dir      "resources/public/js/min"
                :elide-asserts   true
                :closure-defines {goog.DEBUG false}
                :pretty-print    false}}]}

  :figwheel {;; :http-server-root "public" ;; default and assumes "resources"
             ;; :server-port 3449 ;; default
             ;; :server-ip "127.0.0.1"

             :css-dirs ["resources/public/css"] ;; watch and update CSS

             ;; Start an nREPL server into the running figwheel process
             ;; :nrepl-port 7888

             ;; Server Ring Handler (optional)
             ;; if you want to embed a ring handler into the figwheel http-kit
             ;; server, this is for simple ring servers, if this
             ;; doesn't work for you just run your own server :)
             ;; :ring-handler hello_world.server/handler

             ;; To be able to open files in your editor from the heads up display
             ;; you will need to put a script on your path.
             ;; that script will have to take a file path and a line number
             ;; ie. in  ~/bin/myfile-opener
             ;; #! /bin/sh
             ;; emacsclient -n +$2 $1
             ;;
             ;; :open-file-command "myfile-opener"

             ;; if you want to disable the REPL
             ;; :repl false

             ;; to configure a different figwheel logfile path
             ;; :server-logfile "tmp/logs/figwheel-logfile.log"
             })

как мне его переделать под figwheel main?
тоесть под фаил deps.edn?
так чтоб я мог его запускать как clojure -M:fig:build?
есть какойто автоматический способ сформировать ./deps.edn на основе ./project.clj?
*** команда
clojure -Sdeps '{:deps {leiningen/tools.deps.converter {:mvn/version "0.4.2"}}}' \
-m leiningen.tools.deps.converter project.clj
*** вручную

Крутой шаг! 🎯 Переход с **Leiningen + Figwheel Classic** → на **deps.edn + Figwheel Main** — сейчас это “канон” для ClojureScript ✅
Но автоматического конвертера *к сожалению нет* — приходится переносить вручную. Я помогу сделать это красиво и минимально больно 💪

---

## ✅ Что нам надо перенести

Из твоего `project.clj` важны:

| Что                  | Из `project.clj` → В `deps.edn`       |
| -------------------- | ------------------------------------- |
| зависимости          | `:dependencies`                       |
| пути                 | `:source-paths`                       |
| конфиг Figwheel Main | создаём отдельный файл `dev.cljs.edn` |
| запуск               | `clojure -M:fig`                      |

Остальное можно забыть.
`cljsbuild`, `plugins` — **не нужны** в deps.edn мире ❌

---

## ✅ Пример твоего `deps.edn`

Создай `deps.edn` в корне проекта:

```clojure
{:paths ["src" "resources"]

 :deps {org.clojure/clojure            {:mvn/version "1.10.1"}
        org.clojure/clojurescript      {:mvn/version "1.10.597"}
        org.clojure/core.async         {:mvn/version "0.7.559"
                                        :exclusions  [org.clojure/tools.reader]}
        reagent/reagent                {:mvn/version "0.9.1"}
        keechma/keechma                {:mvn/version "0.3.14"
                                        :exclusions [cljsjs/react-with-addons
                                                     cljsjs/react-dom
                                                     cljsjs/react-dom-server]}
        keechma/entitydb               {:mvn/version "0.1.6"}}

 :aliases
 {:fig
  {:extra-deps {com.bhauman/figwheel-main       {:mvn/version "0.2.18"}
                com.bhauman/rebel-readline-cljs {:mvn/version "0.1.4"}}
   :main-opts ["-m" "figwheel.main" "-b" "dev" "-r"]}}}
```

---

## ✅ Добавляем конфиг сборки Figwheel Main

Создай папку:

```
./dev
```

И файл `dev/dev.cljs.edn`:

```clojure
^{:watch-dirs ["src"]
  :css-dirs ["resources/public/css"]}
{:main keechma-todomvc.app}
```

Это заменяет весь твой блок:

```
:cljsbuild
:figwheel
```

---

## ✅ HTML исправить путь к js

В `resources/public/index.html` (или где main HTML):

Заменить:

```html
<script src="js/app.js"></script>
```

На Figwheel Main путь:

```html
<script src="/cljs-out/dev-main.js"></script>
```

(Figwheel сам создаст `cljs-out/`)

---

## ✅ Как запускать теперь 🚀

Режим разработки:

```bash
clojure -M:fig
```

Продакшн-сборка:

```bash
clojure -M:fig -bo dev
```

---

## ✅ Что делать с `project.clj`?

Удали или оставь только как метаданные проекта — он больше не нужен 👍

---

## ✨ Бонус: хотим REPL + автоперезагрузку при изменениях?

Можно также:

```bash
clojure -M:fig -b dev -r
```

---

## 📌 Ответы на твои вопросы

| Вопрос                                                        | Ответ                   |
| ------------------------------------------------------------- | ----------------------- |
| Можно ли автоматически конвертировать project.clj → deps.edn? | ❌ Нет (ручной перенос)  |
| Можно ли запускать через `clojure -M:fig:build`?              | ✅ Да, см. alias         |
| Lein plugins нужны?                                           | ❌ Вообще нет в deps.edn |

---

Хочешь — я могу:
✅ подготовить для тебя всё полностью
✅ проверить что приложение собирается
✅ оптимизировать структуру проекта (src/dev separation)
✅ добавить hot reload React компонент точно как в прежнем figwheel

Хочешь — просто скинь структуру проекта (`tree -L 3`) и я сделаю идеальную миграцию 🔥
*** ошибка
**** 1

#+begin_src html :no-expand t :mkdirp yes 
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Worder • Keechma</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="css/style.css" rel="stylesheet" type="text/css">
    <link rel="icon" href="https://clojurescript.org/images/cljs-logo-icon-32.png">
  </head>
  <body>
    <div id="app"> 
    </div> <!-- end of app div -->
    <script src="cljs-out/dev-main.js" type="text/javascript"></script>
    <script>keechma_todomvc.worder.main()</script>
  </body>
</html>
#+end_src




(ns ^:figwheel-hooks keechma-todomvc.worder
  "# Keechma TodoMVC App"
  (:require [keechma-todomvc.components :as components]
            [keechma-todomvc.controllers.todos :as todos]
            [keechma-todomvc.subscriptions :as subscriptions]
            [keechma.app-state :as app-state]))

(defn multiply [a b] (* a b))

(defonce running-app (atom nil))

;; ## App Definition

(def app-definition
  "Pulls the app together."
  {:routes [[":status" {:status "all"}]]
   :controllers {:todos (todos/->Controller)}
   :components components/system
   :subscriptions subscriptions/subscriptions
   :html-element (.getElementById js/document "app")})

;; ## App Lifecycle

(defn start!
  "Starts the app."
  []
  (reset! running-app (app-state/start! app-definition)))

(defn restart!
  "Restarts the app. `project.clj` contains a config setting for
  `figwheel` requesting a call to this function whenever the code is
  reloaded."
  []
  (if-let [current @running-app]
    (app-state/stop! current start!)
    (start!)))

(defn dev-setup
  "Enables console output for dev builds."
  []
  (when ^boolean js/goog.DEBUG
    (enable-console-print!)
    (println "dev mode")))

;; ## Main

(defn ^:export main
  "Called from `index.html` to start the app. Exported because
  `index.html` refers to it by name even in non-dev builds."
  []
  (dev-setup)
  (start!))


~/Dev/ClojureScript/tutorials/my-cljs-project/worder $ clojure -M:fig:build

[Figwheel] Validating figwheel-main.edn
[Figwheel] figwheel-main.edn is valid \(ツ)/
[Figwheel] Compiling build dev to "target/public/cljs-out/dev-main.js"
[Figwheel] Successfully compiled build dev to "target/public/cljs-out/dev-main.js" in 2.309 seconds.
[Figwheel] Outputting main file: target/public/cljs-out/dev-main-auto-testing.js
[Figwheel] Watching paths: ("test" "src") to compile build - dev
[Figwheel] Starting Server at http://localhost:9500
[Figwheel] Starting REPL
Prompt will show when REPL connects to evaluation environment (i.e. a REPL hosting webpage)
Figwheel Main Controls:
          (figwheel.main/stop-builds id ...)  ;; stops Figwheel autobuilder for ids
          (figwheel.main/start-builds id ...) ;; starts autobuilder focused on ids
          (figwheel.main/reset)               ;; stops, cleans, reloads config, and starts autobuilder
          (figwheel.main/build-once id ...)   ;; builds source one time
          (figwheel.main/clean id ...)        ;; deletes compiled cljs target files
          (figwheel.main/status)              ;; displays current state of system
Figwheel REPL Controls:
          (figwheel.repl/conns)               ;; displays the current connections
          (figwheel.repl/focus session-name)  ;; choose which session name to focus on
In the cljs.user ns, controls can be called without ns ie. (conns) instead of (figwheel.repl/conns)
    Docs: (doc function-name-here)
    Exit: :cljs/quit
 Results: Stored in vars *1, *2, *3, *e holds last exception object
WARNING: A restricted method in java.lang.System has been called
WARNING: java.lang.System::loadLibrary has been called by org.fusesource.hawtjni.runtime.Library in an unnamed module (file:/home/buyn/.m2/repository/org/fusesource/jansi/jansi/1.16/jansi-1.16.jar)
WARNING: Use --enable-native-access=ALL-UNNAMED to avoid a warning for callers in this module
WARNING: Restricted methods will be blocked in a future release unless native access is enabled

[Rebel readline] Type :repl/help for online help info
Opening URL http://localhost:9500
ClojureScript 1.11.132
cljs.user=> 

 util.cljs:187:64
Feature :formatters cannot be installed. Unsupported Javascript context: Mozilla/5.0 (X11; Linux x86_64; rv:142.0) Gecko/20100101 Firefox/142.0. util.cljs:248:15
CLJS DevTools: some custom formatters were not rendered.
https://github.com/binaryage/cljs-devtools/blob/master/docs/faq.md#why-some-custom-formatters-were-not-rendered util.cljs:136:15
Uncaught Error: Bad dependency path or symbol: keechma_todomvc.components.todo_edit
    visit http://localhost:9500/cljs-out/dev/goog/base.js:2349
    visit http://localhost:9500/cljs-out/dev/goog/base.js:2361
    visit http://localhost:9500/cljs-out/dev/goog/base.js:2361
    load_ http://localhost:9500/cljs-out/dev/goog/base.js:2368
    require http://localhost:9500/cljs-out/dev/goog/base.js:832
    <anonymous> http://localhost:9500/:13
base.js:2349:17
    visit http://localhost:9500/cljs-out/dev/goog/base.js:2349
    visit http://localhost:9500/cljs-out/dev/goog/base.js:2361
    visit http://localhost:9500/cljs-out/dev/goog/base.js:2361
    load_ http://localhost:9500/cljs-out/dev/goog/base.js:2368
    require http://localhost:9500/cljs-out/dev/goog/base.js:832
    <anonymous> http://localhost:9500/:13
Uncaught ReferenceError: keechma_todomvc is not defined
    <anonymous> http://localhost:9500/:14
localhost:9500:14:13
    <anonymous> http://localhost:9500/:14
 [goog.net.WebSocket] Opening the WebSocket on ws://localhost:9500/figwheel-connect?fwprocess=7fb158&fwbuild=dev&fwsid=ba3c1dab-1ca9-4ad4-ac61-a614e44e1471 <empty string> console.js:218:20
 [goog.net.WebSocket] WebSocket opened on ws://localhost:9500/figwheel-connect?fwprocess=7fb158&fwbuild=dev&fwsid=ba3c1dab-1ca9-4ad4-ac61-a614e44e1471 <empty string> console.js:218:20
 [Figwheel REPL] Session ID: ba3c1dab-1ca9-4ad4-ac61-a614e44e1471 <empty string> console.js:218:20
 [Figwheel REPL] Session Name: Bridget <empty string>
    <anonymous> http://localhost:9500/:12
**** 2
Installing CLJS DevTools 1.0.5 and enabling features :formatters :hints :async util.cljs:187:64
Feature :formatters cannot be installed. Unsupported Javascript context: Mozilla/5.0 (X11; Linux x86_64; rv:142.0) Gecko/20100101 Firefox/142.0. util.cljs:248:15
CLJS DevTools: some custom formatters were not rendered.
https://github.com/binaryage/cljs-devtools/blob/master/docs/faq.md#why-some-custom-formatters-were-not-rendered util.cljs:136:15
dev mode core.cljs:200:24
Uncaught 
Object { message: "Missing dependencies :todo-edit for component :todo-item", data: {…}, cause: null, name: "Error", description: undefined, number: undefined, fileName: "http://localhost:9500/cljs-out/dev/cljs/core.js", lineNumber: 38425, columnNumber: 10, stack: "cljs$core$ExceptionInfo@http://localhost:9500/cljs-out/dev/cljs/core.js:38425:10\ncljs.core.ex_info.cljs$core$IFn$_invoke$arity$3@http://localhost:9500/cljs-out/dev/cljs/core.js:38486:9\ncljs.core.ex_info.cljs$core$IFn$_invoke$arity$2@http://localhost:9500/cljs-out/dev/cljs/core.js:38482:26\ncljs$core$ex_info@http://localhost:9500/cljs-out/dev/cljs/core.js:38468:26\nkeechma$ui_component$make_ex@http://localhost:9500/cljs-out/dev/keechma/ui_component.js:11:26\nkeechma$ui_component$component_with_deps@http://localhost:9500/cljs-out/dev/keechma/ui_component.js:971:36\nkeechma$ui_component$resolved_system/<@http://localhost:9500/cljs-out/dev/keechma/ui_component.js:1017:86\ncljs.core.seq_reduce.cljs$core$IFn$_invoke$arity$3/nval<@http://localhost:9500/cljs-out/dev/cljs/core.js:8530:98\ncljs.core.seq_reduce.cljs$core$IFn$_invoke$arity$3@http://localhost:9500/cljs-out/dev/cljs/core.js:8531:3\ncljs.core.Cons.prototype.cljs$core$IReduce$_reduce$arity$3@http://localhost:9500/cljs-out/dev/cljs/core.js:11531:29\ncljs.core.reduce.cljs$core$IFn$_invoke$arity$3@http://localhost:9500/cljs-out/dev/cljs/core.js:8684:13\ncljs$core$reduce@http://localhost:9500/cljs-out/dev/cljs/core.js:8648:25\nkeechma$ui_component$resolved_system@http://localhost:9500/cljs-out/dev/keechma/ui_component.js:1012:25\nkeechma.ui_component.system.cljs$core$IFn$_invoke$arity$2@http://localhost:9500/cljs-out/dev/keechma/ui_component.js:1175:51\nkeechma$ui_component$system@http://localhost:9500/cljs-out/dev/keechma/ui_component.js:1155:36\nkeechma$app_state$resolve_main_component@http://localhost:9500/cljs-out/dev/keechma/app_state.js:801:50\nkeechma.app_state.start_BANG_.cljs$core$IFn$_invoke$arity$2@http://localhost:9500/cljs-out/dev/keechma/app_state.js:988:92\nkeechma$app_state$start_BANG_@http://localhost:9500/cljs-out/dev/keechma/app_state.js:970:38\nkeechma.app_state.start_BANG_.cljs$core$IFn$_invoke$arity$1@http://localhost:9500/cljs-out/dev/keechma/app_state.js:980:38\nkeechma$app_state$start_BANG_@http://localhost:9500/cljs-out/dev/keechma/app_state.js:966:38\nkeechma_todomvc$worder$start_BANG_@http://localhost:9500/cljs-out/dev/keechma_todomvc/worder.js:23:105\nkeechma_todomvc$worder$main@http://localhost:9500/cljs-out/dev/keechma_todomvc/worder.js:58:43\n@http://localhost:9500/:14:36\n" }
core.cljs:11778:11
 [goog.net.WebSocket] Opening the WebSocket on ws://localhost:9500/figwheel-connect?fwprocess=b292cc&fwbuild=dev&fwsid=ae8af371-96d0-41d5-ab1c-859cabaf1a7a <empty string> console.js:218:20
 [goog.net.WebSocket] WebSocket opened on ws://localhost:9500/figwheel-connect?fwprocess=b292cc&fwbuild=dev&fwsid=ae8af371-96d0-41d5-ab1c-859cabaf1a7a <empty string> console.js:218:20
 [Figwheel REPL] Session ID: ae8af371-96d0-41d5-ab1c-859cabaf1a7a <empty string> console.js:218:20
 [Figwheel REPL] Session Name: Eufemia <empty string>
**** 3
Installing CLJS DevTools 1.0.5 and enabling features :formatters :hints :async util.cljs:187:64
Feature :formatters cannot be installed. Unsupported Javascript context: Mozilla/5.0 (X11; Linux x86_64; rv:142.0) Gecko/20100101 Firefox/142.0. util.cljs:248:15
CLJS DevTools: some custom formatters were not rendered.
https://github.com/binaryage/cljs-devtools/blob/master/docs/faq.md#why-some-custom-formatters-were-not-rendered util.cljs:136:15
dev mode core.cljs:200:24
Uncaught TypeError: can't access property "call", reagent.core.render_component is undefined
    keechma$app_state$mount_to_element_BANG_ app_state.cljs:200
    cljs$core$IFn$_invoke$arity$2 app_state.cljs:312
    keechma$app_state$start_BANG_ app_state.cljs:258
    cljs$core$IFn$_invoke$arity$1 app_state.cljs:301
    keechma$app_state$start_BANG_ app_state.cljs:258
    keechma_todomvc$worder$start_BANG_ worder.cljs:27
    keechma_todomvc$worder$main worder.cljs:52
    <anonymous> (index):14
app_state.cljs:200:5
 [goog.net.WebSocket] Opening the WebSocket on ws://localhost:9500/figwheel-connect?fwprocess=1af083&fwbuild=dev&fwsid=c6a9dd49-7f6e-4d90-9e13-4a3715118bc4 <empty string> console.js:218:20
 [goog.net.WebSocket] WebSocket opened on ws://localhost:9500/figwheel-connect?fwprocess=1af083&fwbuild=dev&fwsid=c6a9dd49-7f6e-4d90-9e13-4a3715118bc4 <empty string> console.js:218:20
 [Figwheel REPL] Session ID: c6a9dd49-7f6e-4d90-9e13-4a3715118bc4 <empty string> console.js:218:20
 [Figwheel REPL] Session Name: Rolando <empty string> console.js:218:20
*** ИИ
**** index.html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Worder • Keechma</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="css/style.css" rel="stylesheet" type="text/css">
    <link rel="icon" href="https://clojurescript.org/images/cljs-logo-icon-32.png">
  </head>
  <body>
    <div id="app"> 
    </div> <!-- end of app div -->
    <script src="cljs-out/dev-main.js" type="text/javascript"></script>
    <script>keechma_todomvc.worder.main()</script>
  </body>
</html>
**** src deps.edn
#+begin_src clojure :no-expand t
{:deps {org.clojure/clojure {:mvn/version "1.12.0"}
        org.clojure/clojurescript {:mvn/version "1.11.132"}
        org.clojure/data.json {:mvn/version "2.5.1"}
        cljsjs/react {:mvn/version "18.3.1-1"}
        cljsjs/react-dom {:mvn/version "18.3.1-1"}
        org.clojure/core.async     {:mvn/version "0.7.559"
                                    :exclusions  [org.clojure/tools.reader]}
        keechma/keechma            {:mvn/version "0.3.14"
                                    :exclusions [cljsjs/react-with-addons
                                                 cljsjs/react-dom
                                                 cljsjs/react-dom-server]}
        keechma/entitydb           {:mvn/version "0.1.6"}
        reagent/reagent {:mvn/version "1.2.0" }}

 :paths ["src" "resources"]

 :aliases {:fig {:extra-deps
                 {com.bhauman/rebel-readline-cljs {:mvn/version "0.1.4"}
                  com.bhauman/figwheel-main {:mvn/version "0.2.20"}
                  org.slf4j/slf4j-nop {:mvn/version "2.0.16"}}
                 :extra-paths ["target" "test"]}
           :build {:main-opts ["-m" "figwheel.main" "-b" "dev" "-r"]}
           :clean {:main-opts ["-m" "figwheel.main" "--clean" "dev"]}
           :min   {:main-opts ["-m" "figwheel.main" "-O" "advanced" "-bo" "dev"]}
           :test  {:main-opts ["-m" "figwheel.main" "-co" "test.cljs.edn" "-m" "keechma-todomvc.test-runner"]}}}

#+end_src
**** src worder.cljs
#+begin_src clojure :no-expand t :mkdirp yes 
(ns ^:figwheel-hooks keechma-todomvc.worder
  "# Keechma TodoMVC App"
  (:require [keechma-todomvc.components :as components]
            [keechma-todomvc.controllers.todos :as todos]
            [keechma-todomvc.subscriptions :as subscriptions]
            [goog.dom :as gdom]
            [reagent.core :as reagent :refer [atom]]
            [reagent.dom :as rdom]
            [keechma.app-state :as app-state]))

(defn multiply [a b] (* a b))

(defonce running-app (atom nil))

;; ;; ## App Definition

(def app-definition
  "Pulls the app together."
  {:routes [[":status" {:status "all"}]]
   :controllers {:todos (todos/->Controller)}
   :components components/system
   :subscriptions subscriptions/subscriptions
   :html-element (.getElementById js/document "app")})

;; ## App Lifecycle

(defn start!
  "Starts the app."
  []
  (reset! running-app (app-state/start! app-definition)))

(defn restart!
  "Restarts the app. `project.clj` contains a config setting for
  `figwheel` requesting a call to this function whenever the code is
  reloaded."
  []
  (if-let [current @running-app]
    (app-state/stop! current start!)
    (start!)))

(defn dev-setup
  "Enables console output for dev builds."
  []
  (when ^boolean js/goog.DEBUG
    (enable-console-print!)
    (println "dev mode")))

;; ;; ## Main

(defn ^:export main
  "Called from `index.html` to start the app. Exported because
  `index.html` refers to it by name even in non-dev builds."
  []
  (dev-setup)
  (start!))

(println "This text is printed from src/keechma_todomvc/worder.cljs. Go ahead and edit it and see reloading in action.")

;; define your app data so that it doesn't get over-written on reload
(defonce app-state (atom {:text "Hello world!"}))

(defn get-app-element []
  (gdom/getElement "app"))

(defn hello-world []
  [:div
   [:h1 (:text @app-state)]
   [:h3 "Edit this in src/keechma_todomvc/worder.cljs and watch it change!"]])

(defn mount [el]
  (rdom/render [hello-world] el))

(defn mount-app-element []
  (when-let [el (get-app-element)]
    (mount el)))

;; conditionally start your application based on the presence of an "app" element
;; this is particularly helpful for testing this ns without launching the app
(mount-app-element)
(dev-setup)
(start!)

specify reload hook with ^:after-load metadata
(defn ^:after-load on-reload []
  (mount-app-element)
  (dev-setup)
  (start!)
  ;; optionally touch your app-state to force rerendering depending on
  ;; your application
  ;; (swap! app-state update-in [:__figwheel_counter] inc)
)

;; (defn ^:after-load on-reload []
;;   (restart!))
#+end_src
**** нужна помошь
пытаюсь проект с lein figwheel переложить и запустить на figwheel main
figwheel темлпат работает замечательно а вот кичма не запускается

приэтом если я убираю чатьс
specify reload hook with ^:after-load metadata
(defn ^:after-load on-reload []
  (mount-app-element)
  (dev-setup)
  (start!)
  ;; optionally touch your app-state to force rerendering depending on
  ;; your application
  ;; (swap! app-state update-in [:__figwheel_counter] inc)
)

и остоваляю только
(defn ^:after-load on-reload []
  (restart!))

похожо кичм не запускает совсем.
*** Лучшее решение сейчас

Откатить Reagent на последнюю совместимую версию:

reagent/reagent {:mvn/version "0.10.0"}


                 [reagent "0.9.1"]
*** откат
**** ИИ
buyn@ArchSRV:~/Dev/ClojureScript/tutorials/my-cljs-project % git status
On branch main
Your branch is up to date with 'origin/main'.

nothing to commit, working tree clean
buyn@ArchSRV:~/Dev/ClojureScript/tutorials/my-cljs-project % git log --oneline

bf51392 (HEAD -> main, origin/main) ass css
42cb6ae add files from todomvs and fix errors
d49e5f8 add deps to sorce
f92b97e add empty feegwheal templat
bb63b1b add hcain to template converter
d6a3537 add comand for conversio to main
e80a0b3 first change
d36d75d add to Woeder project copy of Toduer
61e3578 add new org project
2486e93 end risoning todomvc
6672ce9 ignor change
87f0a57 clone Keechma todomvc and start risoning
dfe18b0 start risoning
a5ae467 add projrct clone Keechma Counter
bb01003 fix home page
bf86704 new files core and note-form
c537fcb fix bide initialized
631d7d1 add massaging and UI
fe039f5 add new project noter
817e02f add chat
faffa29 Add first components
53e43de fix async
285e637 add files
4fa4514 add grup-chat project and org file
e4fe4d4 tangle error manual fix
4d43c21 start transfer all from book version
de7f8d7 new reagent test app
081e156 add grupchat org
09eaa2d end project
83f46a0 add style
da61c02 add reander header
e911ed5 tagle reander
a897a3c add rehdering
7f9948e fix test
c7b418c srart editing
4e97680 new project contacts
d766099 tagle all
9654579 add promt fun
f505989 add end vwersion of starbase


хорошь меня интересует комит
d6a3537 add comand for conversio to main
и довай превратим его по варианту 3 в отдельный бранчь.
потом мы сможем это бранчь сделать основным? а тот который основной сейчас просто удалить, если понадобится?
**** 1
Да, всё верно 👍
Ты можешь спокойно сделать от нужного коммита **новую ветку**, поработать в ней — и если она станет основной, то потом переключить `main` на неё или вовсе удалить старую.

---

## ✅ Шаг 1 — создать новую ветку от коммита `d6a3537`

```bash
git checkout -b new-main d6a3537
```

Команда создаёт ветку `new-main` и сразу переключает на неё.

Проверка:

```bash
git status
git log --oneline
```

---

## ✅ Шаг 2 — запушить новую ветку на GitHub (если нужно)

```bash
git push -u origin new-main
```

---

## ✅ Что дальше можно сделать

| Цель                                     | Команда                                                         |
| ---------------------------------------- | --------------------------------------------------------------- |
| Сделать новую ветку основной             | через UI GitHub (Settings → Branches) или: `git branch -M main` |
| Удалить старую `main` после переключения | `git push origin --delete main`                                 |
| Или локально удалить старую ветку        | `git branch -D main`                                            |

---

## Если хочешь полностью заменить main новой веткой

Вариант А — после проверки всё ок:

```bash
git checkout main
git reset --hard new-main
git push --force
```

Вариант Б — переименовать новую ветку в main сразу:

```bash
git branch -M main
git push -u origin main --force
```

---

Хочешь — я прослежу с тобой каждый шаг и проверим вместе, чтобы ничего лишнего не затереть ✅
Просто скажи, когда выполнить команду №1 😎**** 

**** 2
Да — это идеальный, **самый безопасный сценарий** ✅
Старый `main` не пропадёт: просто дашь ему новое имя, а свежий бранч станет новым `main`.

Пошагово 👇

---

## ✅ Шаг 1 — ты уже в `new-main` (если нет — выполните)

(предположим, ветка `new-main` уже создана от `d6a3537`)

Проверка:

```bash
git branch
```

Если ты не в `new-main`, то:

```bash
git checkout new-main
```

---

## ✅ Шаг 2 — переименовать старый `main` → например `main-old`

```bash
git branch -m main main-old
```

И отправить переименование на сервер:

```bash
git push origin main-old
```

---

## ✅ Шаг 3 — переименовать текущую ветку `new-main` → `main`

```bash
git branch -m main
```

И сделать её основной на GitHub:

```bash
git push -u origin main
```

GitHub скажет, что старая ветка `main` исчезла — но у нас же есть `main-old` ✅

---

## ✅ Шаг 4 — поправить удалённую ссылку на старый main

На GitHub в → **Settings → Branches → Default branch**
выбираешь `main`.

---

## ✅ Итог

Твоя структура будет выглядеть так:

| Ветка    | Что это                           | Состояние                                  |
| -------- | --------------------------------- | ------------------------------------------ |
| **main** | новая основная ветка от `d6a3537` | активная                                   |
| main-old | бывшая основная ветка             | сохранена для истории, можно удалить позже |

---

Если хочешь — я могу проверить каждый шаг вместе с тобой
Ты просто по очереди отправляй вывод команд:

```bash
git branch
git status
```

Готов подстраховать 💪🔥


**** Ошибка здесь ожидаемая:
Отлично, все шаги прошли идеально 👍
Остался последний логичный штрих ✅

Ошибка здесь ожидаемая:

```
Updates were rejected because the tip of your current branch is behind
its remote counterpart.
```

GitHub всё ещё считает **старый main** главным и не хочет, чтобы ты переписал историю обычным пушем.

---

## ✅ Решение: пушим принудительно — но аккуратно

Ты **на новой ветке `main`**, всё хорошо ✅

Выполни:

```bash
git push -u origin main --force
```

---

## Что будет после этого?

| Ветка на GitHub | Содержание                           |
| --------------- | ------------------------------------ |
| **main**        | твой новый main от `d6a3537`         |
| main-old        | весь прежний код, никуда не исчезнет |

---

## Последнее действие (в браузере)

На GitHub зайди в:

**Repository → Settings → Branches → Default branch**

И переключи `Default` → `main` (тот что новый).

---

Когда сделаешь `push --force` — кинь сюда вывод.
Я рядом, страхую 😎🔥


** DONE сделать комит
** DONE сделать новый фаил компонента
** DONE сделать комит
** DONE компонет измеритель реакции
нужен новый компонет- кнопка
может быть в двух состояниях. Состояние нажатое\активное состояни не активное.
это кнопка сикундомера.
в активном она запоминает состояние в котором она была нажата
и активирует второй компонет который выводит количество прошедших секунд.
при деактивации оно высчитвает сколько секунд прошло и запоминает это значение в переменную

посуте это пример каунтера
много можно взять оттуда
(find-file-other-frame "~/Dev/ClojureScript/tutorials/my-cljs-project/keechma-counter/src/cljs/keechma_counter/ui/main.cljs")
[[file:keechma-counter/src/cljs/keechma_counter/ui/main.cljs::\[:button {:on-click #(ui/send-command ctx :dec)} "-"\]]]
** DONE показатель последнего замера реакции
возможно не компонет а просто хикап структура
** DONE перенести копонет в туду и тем
** DONE добавить компонент замера в туду-итемс
у каждого туду кнопка замерить и результат последнего замера
** DONE сделать отдельный орг
(find-file-other-frame "/home/buyn/Dev/ClojureScript/tutorials/my-cljs-project/worder/worder-cljs-project.org")
** DONE сделать копию проекта
** DONE заменить в разделе файлов на новый путь
* 2025-11-02
** file worder-cljs-project.org
(find-file-other-frame "/home/buyn/Dev/ClojureScript/tutorials/my-cljs-project/worder/worder-cljs-project.org")
** my-cljs-project.org
(find-file-other-frame "/home/buyn/Dev/ClojureScript/tutorials/my-cljs-project/my-cljs-project.org")
